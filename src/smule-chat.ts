// ⠀⠀⠀⠀⠀⠀⠀⢸⠃⠀⠀⡟⠀⢸⡀⠀⠈⠻⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⠞⠋⠁⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⡆⣠⠞⢡⠀⠀⢸⠀
// ⠀⠀⠀⠀⠀⠀⠀⡿⠀⠀⢰⡇⠀⠀⣇⠀⠀⠀⠈⠻⢷⣤⡀⠀⠀⠀⠀⠀⠀⣠⠶⠋⠀⠀⠀⠀⠀⠀⠀⣰⡧⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠖⢚⣿⠞⠁⠀⢸⡄⠀⢸⠀
// ⠀⠀⠀⠀⠀⠀⢸⡇⠀⠀⢸⡇⠀⠈⣿⠀⠀⠀⠀⠀⠀⠙⠻⢷⣦⣀⣀⡴⠋⠁⠀⠀⠀⠀⠀⠀⠀⣠⡾⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡾⠉⠀⠀⠀⣾⣇⠀⠈⡆
// ⠀⠀⠀⠀⠀⠀⢸⠁⠀⠀⢸⡁⠀⠀⢸⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠛⠛⠀⠀⠀⠀⢀⣀⠤⠔⠛⠁⣠⠆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⡞⠀⠀⠀⠀⣰⠇⣿⠀⠀⡇
// ⠀⠀⠀⠀⠀⠀⣾⠀⠀⠀⢸⡇⠀⠀⠀⢧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠀⠀⠀⢠⠴⢻⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⡾⠋⠀⠀⠀⠀⣠⠏⠀⢿⠀⠀⡇
// ⠀⠀⠀⠀⠀⠀⢹⠀⠀⠀⠈⣇⠀⠀⠀⢮⡳⣤⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡞⠀⠀⠀⢠⣤⣤⣤⣤⠶⠛⠉⠀⠀⠀⠀⠀⡴⠋⠀⠀⣼⠀⠀⢻
// ⠀⠀⠀⠀⠀⠀⢸⡇⠀⠀⠀⢹⡄⠀⠀⢸⡏⠉⠉⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣷⠀⠀⠾⠯⠶⢻⠂⠀⠀⠈⠉⠻⠦⣄⣀⠀⠀⠀⠀⡴⢋⣴⠆⠀⠀⣿⠀⠀⣼
// ⠀⠀⠀⠀⠀⠀⠈⣇⠀⠀⠀⠀⠳⡄⠀⠀⢿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⡀⢀⣀⠀⣀⡞⠀⠀⢀⣀⣀⣀⠀⠀⠉⠉⠛⣲⡾⠟⢹⠃⠀⠀⠀⣿⠀⠀⡟
// ⠀⠀⠀⠀⠀⠀⠀⢻⡄⠀⠀⠀⠀⠹⡦⠤⠤⠿⠦⠆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣧⠀⠈⠉⠁⠀⡤⠚⠋⠉⠀⠙⠻⣦⠀⣠⠞⠃⠀⠀⡿⠀⠀⠀⢸⠏⠀⢀⡇
// ⠀⠀⠀⠀⠀⠀⠀⠀⢷⡀⠀⠀⠀⠀⢷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠳⣄⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⡽⠚⠁⠀⠀⠀⢠⡇⢀⣠⣄⡼⠀⠀⡾⠁
// ⠀⠀⠀⠀⠀⠀⠀⠀⠈⠳⣄⠀⠀⠀⠈⢳⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⠲⠤⠤⠤⠖⠒⠚⣩⣽⡿⠀⠀⠀⢀⣠⡾⠓⢉⣟⡾⠃⢀⡼⠁⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⣷⡶⠮⣷⣄⠀⠀⠀⠈⠙⠆⠀⠿⠶⣤⣄⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣶⠿⠋⠁⠀⠀⠀⠀⠈⠀⢀⣴⠟⢋⣠⣶⣋⣀⣀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠈⢳⡀⠀⠈⠳⠄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠛⢷⣦⡑⢄⠀⠀⠀⠀⠀⠀⠀⢰⠂⣠⣶⠟⠋⠀⠀⠀⠀⣀⣀⡀⠀⠀⠋⠉⠀⠉⠁⠀⠀⣠⡾⠋⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢳⣄⠀⠀⠀⠀⠀⠀⠀⢀⣀⣀⣀⣀⣀⣀⣀⣈⡻⣮⣧⠀⠀⠀⠀⠀⠀⣿⣾⣋⣀⣤⣴⣶⠿⠿⠟⠛⠛⠃⠀⠀⠷⢤⣄⣀⣀⣤⣞⣡⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠸⣷⠶⠭⠿⠶⠒⠒⠀⠀⠀⠉⠉⠉⠉⠉⠉⠉⠉⠉⣻⣿⣿⠦⠖⠒⠒⠒⠶⣿⣿⡛⠋⠉⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⣩⡿⠛⠁⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⢷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡾⣏⠀⠀⠀⠀⠀⠀⠀⠀⣼⡇⠉⠀⠀⠀⠀⠀⠀⣼⡇⠀⠀⠀⠀⢀⣤⡴⠛⠉⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠳⢦⣄⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠿⠁⠈⠳⣄⣀⡀⢀⣀⣠⠾⠁⠀⠀⠀⠀⠀⠀⣀⣾⠏⠀⠀⢠⣶⢿⣯⣁⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣴⠟⠋⢉⣁⣀⣀⠀⠀⠀⠸⣆⠀⠀⠀⠀⠀⠀⠀⠈⠉⡏⠁⠀⠀⠀⠀⢀⣀⣠⣴⠾⡟⠁⠀⠒⢻⡟⠀⠀⠀⠙⠻⣦⡀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣴⠟⠁⠀⠀⠈⠻⣄⡀⠀⠀⠀⠀⠻⣄⠀⠀⠀⠀⠀⣀⣤⡶⢿⠛⠛⠛⠛⠛⠛⢻⠁⠙⠲⠇⠀⠀⠴⢯⡤⠻⢶⣤⣄⣀⣈⣷⡀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠸⢿⣥⡀⠀⠀⠀⠀⠸⡞⠛⠒⠂⠀⠀⠀⢯⣻⠶⣶⠶⠟⠋⠁⠀⠘⡆⠀⠀⠀⠀⠀⣼⠀⠀⠀⠀⠀⢀⡴⠊⠁⠀⠈⠙⢮⡉⠉⠛⠁⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠉⠙⠛⠲⢶⡶⠟⠲⠤⡄⠀⠀⠀⠈⠁⠀⠈⣆⠀⠀⠀⠀⠀⠙⠀⠀⠀⠀⣠⠏⠀⠀⠀⠀⠈⠁⢀⣠⣤⠤⠶⠶⠦⢽⡇⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⡟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠳⣄⣀⠀⠀⠀⠀⣀⣠⠞⠁⠀⠀⠀⠀⣀⣴⣞⣉⣀⣀⣀⣀⣴⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣥⡤⢤⣤⣤⢤⣤⣀⡀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠛⠛⠋⠉⠀⠀⠀⢀⣠⠴⠛⠁⠀⠀⠈⠀⠀⣠⠼⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣶⣛⠛⠋⠉⠉⠀⠀⠈⠉⠛⠓⠶⠦⢤⣤⣀⣀⣀⣀⠀⠀⣀⣠⣴⣶⣾⠋⠁⢀⣀⣀⣀⡀⢠⣴⣞⡁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣶⠦⠽⠗⢲⣤⣶⠶⠚⠛⠳⢶⣦⣄⡀⠀⠻⣿⣿⣿⣿⣿⣿⣿⣿⡿⣿⣧⡶⠟⠛⠉⠉⠙⠛⢶⣅⠉⠙⠓⠶⣦⡄⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠻⡄⠀⢀⣿⠋⠀⠀⠀⠀⠀⠀⠀⠙⠿⣶⣄⠈⠙⠛⠻⠟⠛⢫⣵⠾⢋⠏⠀⠀⠀⠀⠀⠀⢠⡏⠙⣷⠀⢠⡾⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⢀⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠻⣦⣸⡏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⣷⡄⠀⠀⢀⣴⠟⠁⢀⡎⠀⠀⠀⠀⠀⠀⠀⡞⠀⠀⠸⣿⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠸⣿⡛⠷⣦⣀⠀⠀⠀⠀⠀⠀⠀⠀⢹⡇⠀⠀⢀⣀⣀⠀⠀⣀⠀⠀⠀⠀⠈⢻⣧⣀⡾⠃⠀⠀⡞⠀⠀⠀⠀⠀⠀⠀⡸⠀⠀⠀⠀⣿⣇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⣄⣀⠘⢷⡄⠀⠙⠳⣄⠀⠀⠀⠀⢀⡴⢻⡇⣠⠞⠋⠉⠉⠛⢯⡝⠀⠀⠀⠀⠀⠀⠙⡿⠁⠀⠀⣸⠁⠀⠀⠀⠀⠀⠀⣰⠃⠀⠀⠀⠀⣿⠸⣧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠉⠙⠓⢾⣷⡀⠀⠀⠘⢷⠀⢀⡴⠋⢀⣼⡷⠋⠀⠀⠀⠀⠀⠀⠹⣆⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⠇⠀⠀⠀⠀⠀⠀⣠⠃⠀⠀⠀⠀⢀⣿⠀⠹⣧⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠈⠉⠀⠀⠀⢸⡾⠋⠀⠀⢸⡟⠁⠀⠀⠀⠀⠀⠀⠀⣀⣯⣤⣄⡀⠀⠀⠀⠀⠀⢀⡇⠀⠀⠀⠀⠀⠀⢰⠏⠀⠀⠀⠀⢀⣼⠋⠀⠀⢹⣧⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⣴⠟⠀⢸⠓⢶⠋⢀⠀⠀⠀⠀⠀⣠⡴⠋⠁⠀⠀⠀⠹⣦⢤⡤⠀⠀⡾⠀⠀⠀⠀⢠⢄⣠⠇⠀⠀⠀⠀⢀⣾⠃⠀⠀⠀⠀⢻⡄⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⢸⡏⠀⠀⢸⠀⢸⣟⣹⡟⠀⠀⠀⠈⢁⡀⠀⠀⠀⠀⠀⠀⣿⠋⠀⠀⡺⠁⠀⠀⠀⢀⣼⡟⠛⠉⠉⠛⠛⠦⣞⡁⠀⠀⠀⠀⠀⢸⡇⠀⠀⠀⠀⠀⠀⠀
//                             yapper
//             (get it? cause you yap in the chat?)

import type { SmuleChatContainer, SmuleChatState, SmulePartnerStatus } from "./types/smule-chat-types"
import { type Client, client, xml } from "@xmpp/client"
import type { AccountIcon } from "./types/smule-types"
import { SmuleUrls } from "./smule-urls"
import { Element } from "@xmpp/xml"
import EventEmitter from "events"
import { JID } from "@xmpp/jid"

//TODO
export class SmuleChat {
    public events: EventEmitter = new EventEmitter()
    public state: SmuleChatState = "closed"
    private client: Client
    private jid: JID
    private ongoingIq = false
    private iqHasMore = false
    private lastIqId = "0"
    private isLive = false
    private roomJID: string = null
    private roomUsers = []

    private chats: { [key: number]: SmuleChatContainer } = {}

    constructor(userId: number, session: string, host = SmuleUrls.userChat, roomJID?: string) {
        this.client = client({
            service: "xmpp://" + host,
            domain: host,
            resource: "smule" + Math.random().toString(16).substring(2, 8), // literally doesnt matter
            username: userId + "",
            password: session
        })

        this.isLive = host != SmuleUrls.userChat || !!roomJID
        this.roomJID = roomJID

        this.client.on("close", (el) => this.onClose(el))
        this.client.on("closing", () => this.onClosing())
        this.client.on("connect", () => this.onConnect())
        this.client.on("connecting", (el) => this.onConnecting(el))
        this.client.on("disconnect", (el) => this.onDisconnect(el))
        this.client.on("disconnecting", () => this.onDisconnecting())
        this.client.on("error", (el) => this.onError(el))
        // this.client.on("input", (el) => this.onInput(el))
        this.client.on("nonza", (el) => this.onNonza(el))
        this.client.on("offline", (el) => this.onOffline(el))
        this.client.on("online", (el) => this.onOnline(el))
        this.client.on("open", () => this.onOpen())
        this.client.on("opening", () => this.onOpening())
        this.client.on("send", (el) => this.onSend(el))
        this.client.on("stanza", (el) => this.onStanza(el))
    }

    /**
     * Establish a connection to Smule's XMPP server.
     */
    public async connect() {
        this.jid = await this.client.start()
        this._log("Connected as:", this.jid.getLocal() + "@" + this.jid.getDomain())
        if (!this.isLive && !this.roomJID) {
            this.client.send(xml("presence", {}))
        } else {
            this.client.send(
                xml(
                    "presence",
                    { to: this.roomJID + "/" + this.jid.getLocal() },
                    xml(
                        "x", 
                        { xmlns: "http://jabber.org/protocol/muc" },
                        xml(
                            "password"
                        ),
                        xml(
                            "history",
                            { maxstanzas: "1"}
                        )
                    )
                )
            )
        }
    }
    /**
     * Disconnects the client from the XMPP server.
     * This method will terminate the active connection
     * and stop any ongoing communication with the server.
     * 
     * @remarks If called when still transmitting data,
     *          it might throw an error (socket write after end).
     */
    public async disconnect() {
        try {
            await this.client.stop()
        } catch {}
    }

    /**
     * Send a chat state to the server. This is used to
     * signal whether you are currently active or not.
     *
     * active -> You're active
     * 
     * composing -> Typing
     * 
     * paused -> Just stopped typing
     * 
     * inactive -> You're inactive
     * 
     * gone -> You're hidden / disconnected / You've left the chat
     * 
     * @param state One of `active`, `composing`, `paused`, `inactive`, or `gone`.
     *              Default is `active`
     */
    public async sendChatState(to: JID | string | AccountIcon, state: SmulePartnerStatus = "active") {
        if (typeof to != "string" && "accountId" in to) to = this.getJIDFromUserId(to.accountId)
        await this.client.send(
            xml(
                "message",
                { to: to.toString(), type: "chat" },
                xml(
                    "chatstate",
                    { xmlns: 'http://jabber.org/protocol/chatstates' },
                    state
                )
            )
        )
    }
    /**
     * Loads the entire message history
     * @param limit The maximum number of messages to fetch. Default is 50.
     * @remarks This currently recurses until it loads ALL archived messages.
     *          This means that it will take a long time to load all messages.
     * @remarks Filtering by a specific JID may not work yet
     */
    public async loadMessageHistory(limit = 50, before = null, after = null, jid?: JID | string) {
        if (!this.isLive) {
            if (this.ongoingIq) this._log("Waiting for previous iq to finish...")
            while (this.ongoingIq) await new Promise((resolve) => setTimeout(resolve, 100))
            if (jid)
                this._log(`Loading ${limit} messages with ${jid}...`)
            else
                this._log(`Loading ${limit} messages from history...`)
    
            // reset all chats before fetching history
            if (!before && !after && !jid) this.chats = {}
    
            this.ongoingIq = true
            await this.client.send(
                xml(
                    'iq',
                    { type: 'set', id: 'mam-query' },
                    xml(
                        'query',
                        { xmlns: 'urn:xmpp:mam:2' },
                        xml('set', { xmlns: 'http://jabber.org/protocol/rsm' },
                            xml('max', {}, limit.toString()),
                            before ? xml('before', {}, before.toString()) : null,
                            after ? xml('after', {}, after.toString()) : null
                        ),
                        jid ? xml('with', {}, jid.toString()) : null
                    )
                )
            )
            while (this.ongoingIq) await new Promise((resolve) => setTimeout(resolve, 100))
            if (this.iqHasMore) await this.loadMessageHistory(limit, null, this.lastIqId, jid)
        } else {
            this._log("Loading live chat history...")
            
            this.ongoingIq = true
            await this.client.send(
                xml(
                    "iq",
                    { from: this.jid.toString(), to: this.roomJID, type: "get", id: "meow" },
                    xml(
                        "query",
                        { xmlns: "http://jabber.org/protocol/muc#history" },
                    )
                )
            )
            while (this.ongoingIq) await new Promise((resolve) => setTimeout(resolve, 100))
        }
    }
    /**
     * Send a text message
     * @param jid The JID to send the message to
     * @param message The message body
     */
    public async sendTextMessage(jid: JID | string | AccountIcon, message: string) {
        if (typeof jid != "string" && "accountId" in jid) jid = this.getJIDFromUserId(jid.accountId)
        await this.client.send(
            xml(
                "message",
                { to: jid.toString(), type: this.isLive ? "groupchat" : "chat" },
                xml("body", {}, message)
            )
        )
        let data = {
            sender: parseInt(this.jid.getLocal()),
            content: message,
        }
        this.chats[this.getUserIdFromJID(jid.toString())].messages.push(data)
        this.events.emit("message", data)
    }
    /**
     * Send a performance / recording 
     * @param jid The JID to send the message to
     * @param performanceKey The performance key to be sent
     */
    public async sendPerformanceMessage(jid: JID | string | AccountIcon, performanceKey: string) {
        if (typeof jid != "string" && "accountId" in jid) jid = this.getJIDFromUserId(jid.accountId)
        await this.client.send(
            xml(
                "message",
                { to: jid.toString(), type: "chat" },
                xml(
                    "performance", 
                    { xmlns: "urn:x-smule:xmpp" }, 
                    xml(
                        "key", 
                        {}, 
                        performanceKey
                    )
                ),
                xml("body", {}, "")
            )
        )
    }
    /**
     * Send a read / received receipt
     * @param jid The JID to inform about it
     */
    public async sendReadReceipt(jid: JID | string | AccountIcon) {
        if (typeof jid != "string" && "accountId" in jid) jid = this.getJIDFromUserId(jid.accountId)
        await this.client.send(
            xml(
                "message",
                { to: jid.toString(), type: "chat" },
                xml("received", { xmlns: "urn:xmpp:receipts" })
            )
        )
    }
    
    //TODO - Most definitely not required
    private async archiveMessage(jid: JID | string | AccountIcon, message: string) {
        if (typeof jid != "string" && "accountId" in jid) jid = this.getJIDFromUserId(jid.accountId)
        await this.client.send(
            xml(
                "iq",
                { type: "set" },
                xml(
                    "archive",
                    { xmlns: "urn:xmpp:mam:2" },
                    xml(
                        "item",
                        { with: jid, id: Math.random().toString(16).substring(2, 8) },
                        xml("body", {}, message)
                    )
                )
            )
        )
    }


    /**
     * Read-only jid to prevent any bugs
     * @returns user's JID
     */
    public fetchJID() {
        return this.jid
    }

    /**
     * Get the smule user id from a JID
     * @param jid The JID to process
     * @returns The JID's smule user id
     */
    public getUserIdFromJID(jid: string|JID) {
        if (!(typeof jid == "string")) return parseInt(jid.getLocal())
        if (jid.includes("/")) return parseInt(jid.split("/")[1])
        return parseInt(jid.split("@")[0])
    }
    /**
     * Get a JID from a smule user id
     * @param userId The smule user id
     * @returns The JID
     */
    public getJIDFromUserId(userId: number|string|AccountIcon) {
        if (typeof userId != "string" && typeof userId != "number" && "accountId" in userId) userId = userId.accountId
        if (this.isLive) return this.roomJID + "/" + userId
        return userId + "@" + this.jid.getDomain()
    }

    //* Processes all message-like elements
    private parseMessage(el: Element) {
        if (el.children.length < 1) return
        this._log(el.toString())

        let child = el.getChildByAttr("xmlns", "http://jabber.org/protocol/chatstates")
        if (child) {
            this._log("Got chatstate!", child.getName())
            this.events.emit("chatstate", {
                sender: this.getUserIdFromJID(el.getAttr("from")),
                state: child.getName()
            })
        }

        child = el.getChildByAttr("xmlns", "urn:xmpp:receipts")
        if (child) {
            this._log("Got receipt!", child.getName())
            this.events.emit("receipt", {
                sender: this.getUserIdFromJID(el.getAttr("from")),
                type: child.getName()
            })
        }

        child = el.getChild("body")
        const perfChild = el.getChild("performance")
        const perfStartChild = el.getChild("performance-start") // live-only
        if (child && (child.getText().trim().length > 0 || perfChild)) {
            this._log("Got message!", child.getText())
            let performanceKey = undefined
            if (perfChild) performanceKey = perfChild.getChild("key").getText()
            let data = {
                content: child.getText(),
                sender: this.getUserIdFromJID(el.getAttr("from")),
                id: el.getAttr("id"),
                performanceKey: performanceKey
            }
            this.events.emit("message", data)
            if (!(data.sender in this.chats)) this.chats[data.sender] = { messages: [] }
            this.chats[data.sender].messages.push(data)
            return
        }

        

        child = el.getChild("result")
        if (!child) return this._log(el.toString())
        child = child.getChild("forwarded")
        if (!child) return this._log(el.toString())
        child = child.getChild("message")
        if (!child) return this._log(el.toString())
        child = child.getChild("body")
        if (!child) return this._log(el.toString())
        this._log("Got message history!", child.getText())

        let performanceKey = undefined
        if (child.parent.getChild("performance")) performanceKey = child.parent.getChild("performance").getChild("key").getText()
        let data = {
            content: child.getText(),
            sender: this.getUserIdFromJID(child.parent.getAttr("from")),
            id: child.parent.getAttr("id"),
            performanceKey: performanceKey
        }
        let chat = this.jid.getLocal().includes(data.sender + "") ? this.getUserIdFromJID(child.parent.getAttr("to")) : data.sender
        this.events.emit("history", data)
        if (!(chat in this.chats)) this.chats[chat] = { messages: [] }
        this.chats[chat].messages.push(data)
    }
    
    private parsePresence(el: Element) {
        if (el.children.length < 1) return
        if (this.isLive) {
            let child = el.getChildByAttr("xmlns", "http://jabber.org/protocol/muc#user")
            if (child) {
                child = child.getChild("item")
                if (child) {
                    if (!el.getAttr("jid")) return
                    let user = this.getUserIdFromJID(el.getAttr("jid"))
                    let role = child.getAttr("role")
                    let affiliation = child.getAttr("affiliation")

                    let data = {
                        user,
                        role,
                        affiliation
                    }
                    this.roomUsers.push(data)
                    this.events.emit("presence", data)
                }
            }
        }
    }

    /**
     * Fetches the chats currently loaded
     * @returns All chats currently loaded
     */
    public fetchChats() { return this.chats }

    /**
     * Fetches a specific chat, if it exists
     * @param user The chat partner id
     * @returns The chat, or an empty new one
     */
    public fetchChat(user: number) {
        if (!(user in this.chats)) this.chats[user] = { messages: [] }
        return this.chats[user]
    }

    public fetchUsers() {
        return this.roomUsers
    }
    

    
//#region Internal events
    private onClose(el: Element) {
        this._log("Closed!:", el)
        this.events.emit("state", "closed")
        this.state = "closed"
    }
    private onClosing() {
        this._log("Closing!")
        this.events.emit("state", "closing")
        this.state = "closing"
    }
    private onConnect() {
        this._log("Connected!")
        this.events.emit("state", "connected")
        this.state = "connected"
    }
    private onConnecting(url: string) {
        this._log("Connecting to", url)
        this.events.emit("state", "connecting")
        this.state = "connecting"
    }
    private onDisconnect({ clean, event }) {
        if (clean) this._log("Disconnected!:" ,event)
        else this._log("Forcibly disconnected!:", event)
        this.events.emit("state", "disconnected")
        this.state = "disconnected"
    }
    private onDisconnecting() {
        this._log("Disconnecting!")
        this.events.emit("state", "disconnecting")
        this.state = "disconnecting"
    }
    private onError(err: Error) {
        this._error("Error!:", err)
        this.events.emit("error", err)
    }
    private onNonza(el: Element) {
        switch (el.getName()) {
            case "stream:features":
                this._log("Got XMPP features!")
                break
            case "proceed":
                this._log("Got XMPP proceed!")
                break
            default:
                this._log("Nonza!")
                break
        }
    }
    private onOffline(el: Element) {
        this._log("Offline!:", el)
        this.events.emit("state", "offline")
        this.state = "offline"
    }
    private onOnline(jid: JID) {
        this._log("Online!:", jid.getLocal() + "@" + jid.getDomain())
        this.events.emit("state", "online")
        this.state = "online"
    }
    private onOpen() {
        this._log("Open!")
        this.events.emit("state", "open")
        this.state = "open"
    }
    private onOpening() {
        this._log("Opening!")
        this.events.emit("state", "opening")
        this.state = "opening"
    }
    private onSend(el: Element) {
        if (el.getName() == "starttls") {
            this._log("Sending TLS stuff!")
        } else {
            this._log("Sent stuff!", el.toString())
        }
    }
    private onStanza(el: Element) {
        if (el.is("message")) {
            this.parseMessage(el)
        } else if (el.is("presence")) {
            this.parsePresence(el)
        } else {
            if (el.is("iq")) {
                let child = el.getChild("fin")
                if (child) {
                    if (child.getAttr("complete") == "false") {
                        this.iqHasMore = true
                        child = child.getChild("set")
                        if (child) {
                            child = child.getChild("last")
                            if (child) {
                                this.lastIqId = child.getText()
                            }
                        }
                    } else {
                        this.iqHasMore = false
                    }
                }
                this.ongoingIq = false
            }
            this._log("Stanza!", el.toString())
        }
    }
//#endregion Internal events

//#region Logging
    private _log(...args: any) {
        console.log(this.isLive ? "[SmuleLiveChat]" : "[SmuleChat]", ...args)
    }
    private _warn(...args: any) {
        console.warn(this.isLive ? "[SmuleLiveChat]" : "[SmuleChat]", ...args)
    }
    private _error(...args: any) {
        console.error(this.isLive ? "[SmuleLiveChat]" : "[SmuleChat]", ...args)
    }
//#endregion Logging
}

