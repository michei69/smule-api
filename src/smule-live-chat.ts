// ⠀⠀⠀⠀⠀⠀⠀⢸⠃⠀⠀⡟⠀⢸⡀⠀⠈⠻⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⠞⠋⠁⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⡆⣠⠞⢡⠀⠀⢸⠀
// ⠀⠀⠀⠀⠀⠀⠀⡿⠀⠀⢰⡇⠀⠀⣇⠀⠀⠀⠈⠻⢷⣤⡀⠀⠀⠀⠀⠀⠀⣠⠶⠋⠀⠀⠀⠀⠀⠀⠀⣰⡧⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠖⢚⣿⠞⠁⠀⢸⡄⠀⢸⠀
// ⠀⠀⠀⠀⠀⠀⢸⡇⠀⠀⢸⡇⠀⠈⣿⠀⠀⠀⠀⠀⠀⠙⠻⢷⣦⣀⣀⡴⠋⠁⠀⠀⠀⠀⠀⠀⠀⣠⡾⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡾⠉⠀⠀⠀⣾⣇⠀⠈⡆
// ⠀⠀⠀⠀⠀⠀⢸⠁⠀⠀⢸⡁⠀⠀⢸⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠛⠛⠀⠀⠀⠀⢀⣀⠤⠔⠛⠁⣠⠆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⡞⠀⠀⠀⠀⣰⠇⣿⠀⠀⡇
// ⠀⠀⠀⠀⠀⠀⣾⠀⠀⠀⢸⡇⠀⠀⠀⢧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠀⠀⠀⢠⠴⢻⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⡾⠋⠀⠀⠀⠀⣠⠏⠀⢿⠀⠀⡇
// ⠀⠀⠀⠀⠀⠀⢹⠀⠀⠀⠈⣇⠀⠀⠀⢮⡳⣤⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡞⠀⠀⠀⢠⣤⣤⣤⣤⠶⠛⠉⠀⠀⠀⠀⠀⡴⠋⠀⠀⣼⠀⠀⢻
// ⠀⠀⠀⠀⠀⠀⢸⡇⠀⠀⠀⢹⡄⠀⠀⢸⡏⠉⠉⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣷⠀⠀⠾⠯⠶⢻⠂⠀⠀⠈⠉⠻⠦⣄⣀⠀⠀⠀⠀⡴⢋⣴⠆⠀⠀⣿⠀⠀⣼
// ⠀⠀⠀⠀⠀⠀⠈⣇⠀⠀⠀⠀⠳⡄⠀⠀⢿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⡀⢀⣀⠀⣀⡞⠀⠀⢀⣀⣀⣀⠀⠀⠉⠉⠛⣲⡾⠟⢹⠃⠀⠀⠀⣿⠀⠀⡟
// ⠀⠀⠀⠀⠀⠀⠀⢻⡄⠀⠀⠀⠀⠹⡦⠤⠤⠿⠦⠆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣧⠀⠈⠉⠁⠀⡤⠚⠋⠉⠀⠙⠻⣦⠀⣠⠞⠃⠀⠀⡿⠀⠀⠀⢸⠏⠀⢀⡇
// ⠀⠀⠀⠀⠀⠀⠀⠀⢷⡀⠀⠀⠀⠀⢷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠳⣄⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⡽⠚⠁⠀⠀⠀⢠⡇⢀⣠⣄⡼⠀⠀⡾⠁
// ⠀⠀⠀⠀⠀⠀⠀⠀⠈⠳⣄⠀⠀⠀⠈⢳⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⠲⠤⠤⠤⠖⠒⠚⣩⣽⡿⠀⠀⠀⢀⣠⡾⠓⢉⣟⡾⠃⢀⡼⠁⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⣷⡶⠮⣷⣄⠀⠀⠀⠈⠙⠆⠀⠿⠶⣤⣄⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣶⠿⠋⠁⠀⠀⠀⠀⠈⠀⢀⣴⠟⢋⣠⣶⣋⣀⣀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠈⢳⡀⠀⠈⠳⠄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠛⢷⣦⡑⢄⠀⠀⠀⠀⠀⠀⠀⢰⠂⣠⣶⠟⠋⠀⠀⠀⠀⣀⣀⡀⠀⠀⠋⠉⠀⠉⠁⠀⠀⣠⡾⠋⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢳⣄⠀⠀⠀⠀⠀⠀⠀⢀⣀⣀⣀⣀⣀⣀⣀⣈⡻⣮⣧⠀⠀⠀⠀⠀⠀⣿⣾⣋⣀⣤⣴⣶⠿⠿⠟⠛⠛⠃⠀⠀⠷⢤⣄⣀⣀⣤⣞⣡⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠸⣷⠶⠭⠿⠶⠒⠒⠀⠀⠀⠉⠉⠉⠉⠉⠉⠉⠉⠉⣻⣿⣿⠦⠖⠒⠒⠒⠶⣿⣿⡛⠋⠉⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⣩⡿⠛⠁⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⢷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡾⣏⠀⠀⠀⠀⠀⠀⠀⠀⣼⡇⠉⠀⠀⠀⠀⠀⠀⣼⡇⠀⠀⠀⠀⢀⣤⡴⠛⠉⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠳⢦⣄⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠿⠁⠈⠳⣄⣀⡀⢀⣀⣠⠾⠁⠀⠀⠀⠀⠀⠀⣀⣾⠏⠀⠀⢠⣶⢿⣯⣁⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣴⠟⠋⢉⣁⣀⣀⠀⠀⠀⠸⣆⠀⠀⠀⠀⠀⠀⠀⠈⠉⡏⠁⠀⠀⠀⠀⢀⣀⣠⣴⠾⡟⠁⠀⠒⢻⡟⠀⠀⠀⠙⠻⣦⡀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣴⠟⠁⠀⠀⠈⠻⣄⡀⠀⠀⠀⠀⠻⣄⠀⠀⠀⠀⠀⣀⣤⡶⢿⠛⠛⠛⠛⠛⠛⢻⠁⠙⠲⠇⠀⠀⠴⢯⡤⠻⢶⣤⣄⣀⣈⣷⡀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠸⢿⣥⡀⠀⠀⠀⠀⠸⡞⠛⠒⠂⠀⠀⠀⢯⣻⠶⣶⠶⠟⠋⠁⠀⠘⡆⠀⠀⠀⠀⠀⣼⠀⠀⠀⠀⠀⢀⡴⠊⠁⠀⠈⠙⢮⡉⠉⠛⠁⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠉⠙⠛⠲⢶⡶⠟⠲⠤⡄⠀⠀⠀⠈⠁⠀⠈⣆⠀⠀⠀⠀⠀⠙⠀⠀⠀⠀⣠⠏⠀⠀⠀⠀⠈⠁⢀⣠⣤⠤⠶⠶⠦⢽⡇⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⡟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠳⣄⣀⠀⠀⠀⠀⣀⣠⠞⠁⠀⠀⠀⠀⣀⣴⣞⣉⣀⣀⣀⣀⣴⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣥⡤⢤⣤⣤⢤⣤⣀⡀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠛⠛⠋⠉⠀⠀⠀⢀⣠⠴⠛⠁⠀⠀⠈⠀⠀⣠⠼⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣶⣛⠛⠋⠉⠉⠀⠀⠈⠉⠛⠓⠶⠦⢤⣤⣀⣀⣀⣀⠀⠀⣀⣠⣴⣶⣾⠋⠁⢀⣀⣀⣀⡀⢠⣴⣞⡁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣶⠦⠽⠗⢲⣤⣶⠶⠚⠛⠳⢶⣦⣄⡀⠀⠻⣿⣿⣿⣿⣿⣿⣿⣿⡿⣿⣧⡶⠟⠛⠉⠉⠙⠛⢶⣅⠉⠙⠓⠶⣦⡄⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠻⡄⠀⢀⣿⠋⠀⠀⠀⠀⠀⠀⠀⠙⠿⣶⣄⠈⠙⠛⠻⠟⠛⢫⣵⠾⢋⠏⠀⠀⠀⠀⠀⠀⢠⡏⠙⣷⠀⢠⡾⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⢀⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠻⣦⣸⡏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⣷⡄⠀⠀⢀⣴⠟⠁⢀⡎⠀⠀⠀⠀⠀⠀⠀⡞⠀⠀⠸⣿⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠸⣿⡛⠷⣦⣀⠀⠀⠀⠀⠀⠀⠀⠀⢹⡇⠀⠀⢀⣀⣀⠀⠀⣀⠀⠀⠀⠀⠈⢻⣧⣀⡾⠃⠀⠀⡞⠀⠀⠀⠀⠀⠀⠀⡸⠀⠀⠀⠀⣿⣇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⣄⣀⠘⢷⡄⠀⠙⠳⣄⠀⠀⠀⠀⢀⡴⢻⡇⣠⠞⠋⠉⠉⠛⢯⡝⠀⠀⠀⠀⠀⠀⠙⡿⠁⠀⠀⣸⠁⠀⠀⠀⠀⠀⠀⣰⠃⠀⠀⠀⠀⣿⠸⣧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠉⠙⠓⢾⣷⡀⠀⠀⠘⢷⠀⢀⡴⠋⢀⣼⡷⠋⠀⠀⠀⠀⠀⠀⠹⣆⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⠇⠀⠀⠀⠀⠀⠀⣠⠃⠀⠀⠀⠀⢀⣿⠀⠹⣧⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠈⠉⠀⠀⠀⢸⡾⠋⠀⠀⢸⡟⠁⠀⠀⠀⠀⠀⠀⠀⣀⣯⣤⣄⡀⠀⠀⠀⠀⠀⢀⡇⠀⠀⠀⠀⠀⠀⢰⠏⠀⠀⠀⠀⢀⣼⠋⠀⠀⢹⣧⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⣴⠟⠀⢸⠓⢶⠋⢀⠀⠀⠀⠀⠀⣠⡴⠋⠁⠀⠀⠀⠹⣦⢤⡤⠀⠀⡾⠀⠀⠀⠀⢠⢄⣠⠇⠀⠀⠀⠀⢀⣾⠃⠀⠀⠀⠀⢻⡄⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⢸⡏⠀⠀⢸⠀⢸⣟⣹⡟⠀⠀⠀⠈⢁⡀⠀⠀⠀⠀⠀⠀⣿⠋⠀⠀⡺⠁⠀⠀⠀⢀⣼⡟⠛⠉⠉⠛⠛⠦⣞⡁⠀⠀⠀⠀⠀⢸⡇⠀⠀⠀⠀⠀⠀⠀
//                             yapper
//             (get it? cause you yap in the chat?)

import type { SmuleChatContainer, SmuleChatState, SmulePartnerStatus } from "./smule-chat-types"
import { type Client, client, xml } from "@xmpp/client"
import type { AccountIcon } from "./smule-types"
import { SmuleUrls } from "./smule-urls"
import { Element } from "@xmpp/xml"
import EventEmitter from "events"
import { JID } from "@xmpp/jid"

//TODO
export class SmuleLiveChat {
    public events: EventEmitter = new EventEmitter()
    public state: SmuleChatState = "closed"
    private client: Client
    private jid: JID
    private ongoingIq = false
    private iqHasMore = false
    private lastIqId = "0"
    private roomJID: string = null
    private roomUsers = []

    private chat: SmuleChatContainer = { messages: [] }

    constructor(userId: number, session: string, host = SmuleUrls.userChat, roomJID?: string) {
        this.client = client({
            service: "xmpp://" + host,
            domain: host,
            resource: "smule" + Math.random().toString(16).substring(2, 8), // literally doesnt matter
            username: userId + "",
            password: session
        })

        this.roomJID = roomJID

        this.client.on("close", (el) => this.onClose(el))
        this.client.on("closing", () => this.onClosing())
        this.client.on("connect", () => this.onConnect())
        this.client.on("connecting", (el) => this.onConnecting(el))
        this.client.on("disconnect", (el) => this.onDisconnect(el))
        this.client.on("disconnecting", () => this.onDisconnecting())
        this.client.on("error", (el) => this.onError(el))
        // this.client.on("input", (el) => this.onInput(el))
        this.client.on("nonza", (el) => this.onNonza(el))
        this.client.on("offline", (el) => this.onOffline(el))
        this.client.on("online", (el) => this.onOnline(el))
        this.client.on("open", () => this.onOpen())
        this.client.on("opening", () => this.onOpening())
        this.client.on("send", (el) => this.onSend(el))
        this.client.on("stanza", (el) => this.onStanza(el))
    }

    /**
     * Establish a connection to Smule's XMPP server.
     */
    public async connect() {
        this.jid = await this.client.start()
        this._log("Connected as:", this.jid.getLocal() + "@" + this.jid.getDomain())
        this.client.send(
            xml(
                "presence",
                { to: this.roomJID + "/" + this.jid.getLocal() },
                xml(
                    "x", 
                    { xmlns: "http://jabber.org/protocol/muc" },
                    xml(
                        "password"
                    ),
                    xml(
                        "history",
                        { maxstanzas: "1"}
                    )
                )
            )
        )
    }
    /**
     * Disconnects the client from the XMPP server.
     * This method will terminate the active connection
     * and stop any ongoing communication with the server.
     * 
     * @remarks If called when still transmitting data,
     *          it might throw an error (socket write after end).
     */
    public async disconnect() {
        try {
            await this.client.stop()
        } catch {}
    }

    /**
     * Send a chat state to the server. This is used to
     * signal whether you are currently active or not.
     *
     * active -> You're active
     * 
     * composing -> Typing
     * 
     * paused -> Just stopped typing
     * 
     * inactive -> You're inactive
     * 
     * gone -> You're hidden / disconnected / You've left the chat
     * 
     * @param state One of `active`, `composing`, `paused`, `inactive`, or `gone`.
     *              Default is `active`
     */
    public async sendChatState(to: JID | string | AccountIcon, state: SmulePartnerStatus = "active") {
        if (typeof to != "string" && "accountId" in to) to = this.getJIDFromUserId(to.accountId)
        await this.client.send(
            xml(
                "message",
                { to: to.toString(), type: "chat" },
                xml(
                    "chatstate",
                    { xmlns: 'http://jabber.org/protocol/chatstates' },
                    state
                )
            )
        )
    }
    /**
     * Loads the entire message history
     * @param limit The maximum number of messages to fetch. Default is 50.
     * @remarks This currently recurses until it loads ALL archived messages.
     *          This means that it will take a long time to load all messages.
     * @remarks Filtering by a specific JID may not work yet
     */
    public async loadMessageHistory(limit = 50, before = null, after = null, jid?: JID | string) {
        this._log("Loading live chat history...")
        
        this.ongoingIq = true
        await this.client.send(
            xml(
                "iq",
                { from: this.jid.toString(), to: this.roomJID, type: "get", id: "meow" },
                xml(
                    "query",
                    { xmlns: "http://jabber.org/protocol/muc#history" },
                )
            )
        )
        while (this.ongoingIq) await new Promise((resolve) => setTimeout(resolve, 100))
    }
    /**
     * Send a text message
     * @param jid The JID to send the message to
     * @param message The message body
     */
    public async sendTextMessage(jid: JID | string | AccountIcon, message: string) {
        if (typeof jid != "string" && "accountId" in jid) jid = this.getJIDFromUserId(jid.accountId)
        await this.client.send(
            xml(
                "message",
                { to: jid.toString(), type: "groupchat" },
                xml("body", {}, message)
            )
        )
        const data = {
            sender: parseInt(this.jid.getLocal()),
            content: message,
        }
        this.chat[this.getUserIdFromJID(jid.toString())].messages.push(data)
        this.events.emit("message", data)
    }


    /**
     * Read-only jid to prevent any bugs
     * @returns user's JID
     */
    public fetchJID() {
        return this.jid
    }

    /**
     * Get the smule user id from a JID
     * @param jid The JID to process
     * @returns The JID's smule user id
     */
    public getUserIdFromJID(jid: string|JID) {
        if (!(typeof jid == "string")) return parseInt(jid.getLocal())
        if (jid.includes("/")) return parseInt(jid.split("/")[1])
        return parseInt(jid.split("@")[0])
    }
    /**
     * Get a JID from a smule user id
     * @param userId The smule user id
     * @returns The JID
     */
    public getJIDFromUserId(userId: number|string|AccountIcon) {
        if (typeof userId != "string" && typeof userId != "number" && "accountId" in userId) userId = userId.accountId
        return this.roomJID + "/" + userId
    }

    //* Processes all message-like elements
    private parseMessage(el: Element) {
        if (el.children.length < 1) return
        this._log(el.toString())

        // on new message
        let child = el.getChild("body")
        if (child && child.getText().trim().length > 0) {
            this._log("Got message!", child.getText())
            const data = {
                content: child.getText(),
                sender: this.getUserIdFromJID(el.getAttr("from")),
                id: el.getAttr("id"),
            }
            this.events.emit("message", data)
            this.chat.messages.push(data)
            return
        }
        
        // on song switch
        child = el.getChild("performance-start")
        if (child) {
            const data = {
                arrKey: child.getChild("arr-key").getText(),
                arrVer: child.getChild("arr-ver").getText(),
                arrArtist: child.getChild("arr-artist").getText(),
                arrName: child.getChild("arr-name").getText(),
                perfKey: child.getChild("perf-key").getText(),
                perfAcctHandle: child.getChild("perf-acct-handle").getText(),
                id: el.getAttr("id"),
            }
            this._log("Got performance start!", data)
            this.events.emit("performanceStart", data)
        }

        // on mic request
        child = el.getChild("create-mic-request")
        if (child) {
            const data = {
                occupantId: child.getChild("occupant-id").getText(),
                timestamp: child.getChild("timestamp").getText(),
                text: child.getChild("text").getText(),
                id: el.getAttr("id"),
            }
            this._log("Got mic request!", data)
            this.events.emit("createMicRequest", data)
        }

        // on cancel mic request
        child = el.getChild("cancel-mic-request")
        if (child) {
            const data = {
                occupantId: child.getChild("occupant-id").getText(),
                id: el.getAttr("id"),
            }
            this._log("Got cancel mic request!", data)
            this.events.emit("cancelMicRequest", data)
        }

        // on gift sent
        child = el.getChild("gift-sent")
        if (child) {
            const data = {
                senderId: child.getChild("sender-id").getText(),
                recipientId: child.getChild("recipient-id").getText(),
                giftId: child.getChild("gift-id").getText(),
                giftCount: child.getChild("gift-count").getText(),
                transactionId: child.getChild("transaction-id").getText(),
                note: child.getChild("note").getText(),
                id: el.getAttr("id"),
            }
            this._log("Got gift sent!", data)
            this.events.emit("giftSent", data)
        }

        // on new host
        child = el.getChild("host-session-started")
        if (child) {
            const data = {
                hostId: child.getChild("host-occupant-id").getText(),
                sessionId: child.getChild("host-session-id").getText(),
                agoraUserId: child.getChild("host-agora-user-id").getText(),
                id: el.getAttr("id"),
            }
            this._log("Got new host!", data)
            this.events.emit("new-host", data)
        }

        // on host left
        child = el.getChild("host-session-ended")
        if (child) {
            const data = {
                hostId: child.getChild("host-occupant-id").getText(),
                reason: child.getChild("reason").getText(),
                id: el.getAttr("id"),
            }
            this._log("Got host left!", data)
            this.events.emit("host-left", data)
        }


        // on history received
        child = el.getChild("result")
        if (!child) return
        child = child.getChild("forwarded")
        if (!child) return
        child = child.getChild("message")
        if (!child) return
        child = child.getChild("body")
        if (!child) return
        this._log("Got message history!", child.getText())

        const data = {
            content: child.getText(),
            sender: this.getUserIdFromJID(child.parent.getAttr("from")),
            id: child.parent.getAttr("id"),
        }
        this.events.emit("history", data)
        this.chat.messages.push(data)
    }
    
    private parsePresence(el: Element) {
        if (el.children.length < 1) return
        let child = el.getChildByAttr("xmlns", "http://jabber.org/protocol/muc#user")
        if (child) {
            child = child.getChild("item")
            if (child) {
                if (!el.getAttr("jid")) return
                const data = {
                    user: this.getUserIdFromJID(el.getAttr("jid")),
                    role: child.getAttr("role"),
                    affiliation: child.getAttr("affiliation"),
                }
                this._log("Got presence!", data)
                this.roomUsers.push(data)
                this.events.emit("presence", data)
            }
        }
    }

    /**
     * Fetches the currently loaded chat
     * @returns All the messages currently loaded
     */
    public fetchChat() { return this.chat }


    public fetchUsers() {
        return this.roomUsers
    }
    

    
//#region Internal events
    private onClose(el: Element) {
        this._log("Closed!:", el)
        this.events.emit("state", "closed")
        this.state = "closed"
    }
    private onClosing() {
        this._log("Closing!")
        this.events.emit("state", "closing")
        this.state = "closing"
    }
    private onConnect() {
        this._log("Connected!")
        this.events.emit("state", "connected")
        this.state = "connected"
    }
    private onConnecting(url: string) {
        this._log("Connecting to", url)
        this.events.emit("state", "connecting")
        this.state = "connecting"
    }
    private onDisconnect({ clean, event }) {
        if (clean) this._log("Disconnected!:" ,event)
        else this._log("Forcibly disconnected!:", event)
        this.events.emit("state", "disconnected")
        this.state = "disconnected"
    }
    private onDisconnecting() {
        this._log("Disconnecting!")
        this.events.emit("state", "disconnecting")
        this.state = "disconnecting"
    }
    private onError(err: Error) {
        this._error("Error!:", err)
        this.events.emit("error", err)
    }
    private onNonza(el: Element) {
        switch (el.getName()) {
            case "stream:features":
                this._log("Got XMPP features!")
                break
            case "proceed":
                this._log("Got XMPP proceed!")
                break
            default:
                this._log("Nonza!")
                break
        }
    }
    private onOffline(el: Element) {
        this._log("Offline!:", el)
        this.events.emit("state", "offline")
        this.state = "offline"
    }
    private onOnline(jid: JID) {
        this._log("Online!:", jid.getLocal() + "@" + jid.getDomain())
        this.events.emit("state", "online")
        this.state = "online"
    }
    private onOpen() {
        this._log("Open!")
        this.events.emit("state", "open")
        this.state = "open"
    }
    private onOpening() {
        this._log("Opening!")
        this.events.emit("state", "opening")
        this.state = "opening"
    }
    private onSend(el: Element) {
        if (el.getName() == "starttls") {
            this._log("Sending TLS stuff!")
        } else {
            this._log("Sent stuff!", el.toString())
        }
    }
    private onStanza(el: Element) {
        if (el.is("message")) {
            this.parseMessage(el)
        } else if (el.is("presence")) {
            this.parsePresence(el)
        } else {
            if (el.is("iq")) {
                let child = el.getChild("fin")
                if (child) {
                    if (child.getAttr("complete") == "false") {
                        this.iqHasMore = true
                        child = child.getChild("set")
                        if (child) {
                            child = child.getChild("last")
                            if (child) {
                                this.lastIqId = child.getText()
                            }
                        }
                    } else {
                        this.iqHasMore = false
                    }
                }
                this.ongoingIq = false
            }
            this._log("Stanza!", el.toString())
        }
    }
//#endregion Internal events

//#region Logging
    private _log(...args: any) {
        console.log("[SmuleLiveChat]", ...args)
    }
    private _warn(...args: any) {
        console.warn("[SmuleLiveChat]", ...args)
    }
    private _error(...args: any) {
        console.error("[SmuleLiveChat]", ...args)
    }
//#endregion Logging
}

