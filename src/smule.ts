// ⠀⠀⠀⠀⠀⠀⠀⠙⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⢺⣿⣿⡆⠀⠀⠀⠀⠀⠀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⡇⠀⠀⠀⠀⠀⠀⣾⢡⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢢⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠈⣿⣿⣷⡦⠀⠀⠀⠀⢰⣿⣿⣷⠀⠀⠀⠀⠀⠀⠀⠀⠃⣠⣾⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⢻⣿⣿⣿⣆⠀⠀⠀⣾⣿⣿⣿⣷⠄⠀⠰⠤⣀⠀⠀⣴⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠃⢺⣿⣿⣿⣿⡄⠀⠀⣿⣿⢿⣿⣿⣦⣦⣦⣶⣼⣭⣼⣿⣿⣿⠇⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢿⣿⣿⣿⣷⡆⠂⣿⣿⣞⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢙⣿⣿⣿⣿⣷⠸⣿⣿⣿⣿⣿⣿⠟⠻⣿⣿⣿⣿⡿⣿⣿⣷⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠄⢿⣿⣿⣿⣿⡄⣿⣿⣿⣿⣿⣿⡀⢀⣿⣿⣿⣿⠀⢸⣿⣿⠅⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⣿⣿⣿⣿⣇⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠠⢐⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣤⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⢀⣴⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⡀⣠⣾⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡔⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⢁⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠠⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣄⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⣀⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⣻⣿⣿⣿⣿⣿⡟⠋⠙⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠙⢿⣿⣿⣿⣿⣿⣿⣄⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⣿⣿⣿⣿⣿⡿⠋⠀⠀⠀⢿⣿⣿⣿⣿⣿⣿⠿⢿⡿⠛⠋⠁⠀⠀⠈⠻⣿⣿⣿⣿⣿⣿⣅⠀⠀⠀⠀⠀
// ⠀⠀⠀⣿⣿⣿⣿⡟⠃⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢻⣿⣿⣿⣿⣿⣤⡀⠀⠀⠀
// ⠀⠜⢠⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⢿⣿⣿⣿⣿⣿⣗⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢻⣿⣿⣿⣿⣿⣦⠄⣠⠀
// ⠠⢸⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⢀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣿⣿⣿⣿
// ⠀⠛⣿⣿⣿⡿⠏⠀⠀⠀⠀⠀⠀⢳⣾⣿⣿⣿⣿⣿⣿⡶⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⣿⣿⣿
// ⠀ ⠀⠉⠉⠀⠀⠀⠀⠀⠀⠀⠀⠙⣿⣿⡿⡿⠿⠛⠙⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠹⠏⠉⠻⠿⠟⠁
import type { AccountExploreResult, AccountIcon, ApiResponse, ArrByKeysResult, ArrResult, AutocompleteResult, AvTemplateCategoryListResult, CampfireExploreResult, CampfireSyncResult, CategoryListResult, CategorySongsResult, CommentLikesResult, EnsembleType, FolloweeResult, FollowersResult, FollowingResult, InviteListResult, InviteMeResult, LoginAsGuestResult, LoginResult, PerformanceByKeysResult, PerformanceCommentsResult, PerformanceCreateCommentResult, PerformanceCreateResult, PerformanceDetail, PerformanceDetailsResult, PerformanceIcon, PerformanceList, PerformancePartsResult, PerformanceResult, PerformancesByAvTemplateResult, PerformancesByUserResult, PerformancesFillStatus, PerformanceSortMethod, PerformancesSortOrder, PlaylistExploreResult, PlaylistGetResult, PreuploadResult, ProfileResult, ProfileViewsResult, SearchResult, SearchResultSort, SearchResultType, SettingsResult, SFAMExploreResult, SocialBlockListResult, SocialFeedListResult, SongbookResult, TrendingSearchResult, UsersLookupResult } from "./smule-types";
import { AutocompleteRequest, AvTemplateCategoryListRequest, CategorySongsRequest, IsFollowingRequest, LoginAsGuestRequest, LoginRefreshRequest, LoginRequest, PerformanceCreateRequest, PerformancePartsRequest, PerformancesByUserRequest, PerformancesListRequest, PreuploadRequest, ProfileRequest, SearchRequest, SettingsRequest, SongbookRequest, UpdateFollowingRequest } from "./smule-requests";
import { PerformanceReq, SmuleSession, SmuleErrorCode } from "./smule-types";
import type { SmulePartnerStatus } from "./smule-chat-types";
import { CustomFormData, SmuleUtil, Util } from "./util";
import axios, { type AxiosResponse } from "axios";
import { SmuleLiveChat } from "./smule-live-chat";
import { SmuleAudio } from "./smule-audio";
import { SmuleMIDI } from "./smule-midi";
import { SmuleUrls } from "./smule-urls";
import { SmuleChat } from "./smule-chat";
import { readFileSync } from "fs";
import * as crypto from "crypto";
import { JID } from "@xmpp/jid";

export const APP_VERSION = "12.0.9"

/**
 * Namespace for Smule's digest parameter found in http requests
 * 
 * Basically, it takes in certain "required" parameters, the body,
 * and a few more pieces of data, alongside the path; concatenates them
 * together, prepends a static salt, and then creates a sha1 digest
 */
export namespace SmuleDigest {
    //* This is pulled from libcma.so, which is responsible for the native digest
    //* Specifically, Java_com_smule_android_AppDelegate_initNative,
    //* the string that comes right after __android_log_print(6,"AppDelegate","Using X KEYS!");
    const SALT = `c2250918de500e32c37842f2d25d4d8210992a0ae96a7f36c4c9703cc675d02b92968bc4fa7feada`
    export function _calculateDigest(encodedPath: string, digestParameters: string): string {
        const shasum = crypto.createHash("sha1")
        return shasum.update(SALT + encodedPath + digestParameters).digest("hex")
    }
    function _getDigestParameters(
        parameters: { [key: string]: string },
        needsSession = false,
        isGetRequest = false,
        multiPartBody: CustomFormData = null,
    ) {
        let neededParameters = {}
        let required = ["appVersion", "app", "appVariant", "msgId"]
        if (needsSession) required.push("session")

        for (let param of required) {
            if (!parameters[param])
                throw new Error(`Missing parameter ${param}`)

            neededParameters[param] = parameters[param]
        }
        if (parameters["ftrack"]) neededParameters["ftrack"] = parameters["ftrack"]

        if (isGetRequest) {
            for (let param of Object.keys(parameters)) {
                neededParameters[param] = parameters[param]
            }
        }
        if (multiPartBody != null) {
            // this is during a performance upload
            neededParameters["pop"] = parameters["pop"]

            neededParameters["jsonData"] = multiPartBody.get("jsonData")
        }

        return neededParameters
    }
    function _runDigestCalculation(
        parameters: { [key: string]: string },
        urlPath: string,
        body = ""
    ) {
        let tempString = ""
        for (let name of Object.keys(parameters).sort()) {
            tempString += name + parameters[name]
        }
        if (body != "" && body != null) tempString += body

        if (urlPath == "/v2/perf/upload") {
            console.log(urlPath, tempString, body)
        }
        return _calculateDigest(urlPath, tempString)
    }

    /**
     * Calculates the SHA1 digest required for
     * HTTP requests to smule's api
     * 
     * @param urlPath The path of the request
     * @param parameters The query parameters of the request
     * @param body The body of the request
     * @param needsSession Whether or not session is required for this request
     * @param isGetRequest Whether or not this is a GET request
     * @param isMultiPartBody Whether or not the body is multipart
     * @returns SHA1 digest
     */
    export function calculateDigest(
        urlPath: string,
        parameters: { [key: string]: string } | URLSearchParams,
        body = "",
        needsSession = false,
        isGetRequest = false,
        multiPartBody: CustomFormData = null
    ) {
        if (parameters instanceof URLSearchParams) parameters = Util.queryToObject(parameters)
        urlPath = Util.getPathFromFullUrl(urlPath)
        let digestParameters = _getDigestParameters(parameters, needsSession, isGetRequest, multiPartBody)
        return _runDigestCalculation(digestParameters, urlPath, multiPartBody ? null : body)
    }
}

//#region Logging
function _log(...args: any) {
    console.log("[SmuleAPI]", ...args)
}
function _warn(...args: any) {
    console.warn("[SmuleAPI]", ...args)
}
function _error(...args: any) {
    console.error("[SmuleAPI]", ...args)
}
//#endregion

/**
 * The public interface for Smule's API
 */
export class Smule {
    /**
     * The current smule session
     */
    session = new SmuleSession()
    /**
     * The current chat session
     */
    dmSession: SmuleChat
    /**
     * The current live chat session
     */
    liveChatSession: SmuleLiveChat
    private msgId = 1000 // automatically incremented value
    private ax = axios.create({
        validateStatus: () => true
    })

    /**
     * Internal stuff
     */
    private internal = {
        /**
         * @returns Whether or not the request has been successful 
         */
        _handleNon200: (response: AxiosResponse): boolean => {
            if (response.status == 200) {
                let data: ApiResponse<any> = response.data
                if (data.status.code == 0) return true
                else {
                    _warn(`[${response.request.path}] Got ${data.status.code} - ${data.status.message ?? SmuleErrorCode[data.status.code]}`)
                    _warn("Provided:", response.config.data)
                    _warn("Received:", data)
                    // _warn(response)
                    return false
                }
            }

            if (response.request && response.request.path) {
                _warn(`[${response.request.path}] Got ${response.status} - ${response.statusText}`)
                _warn(response.data)
            } else {
                _warn(`[NO REQUEST?] Got ${response.status} - ${response.statusText}`)
                _warn(response.data)
            }
            return false
        },

        _createRequestMultiPart: async (url: string, pop: string, body: CustomFormData, checkSession: boolean = true) => {
            let params = new URLSearchParams()
            params.append("pop", pop)
            if (checkSession && this.session && this.session.sessionToken && !this.session.expired) {
                params.append("session", decodeURIComponent(this.session.sessionToken))
            }
            params.append("msgId", this.msgId.toString())
            params.append("appVersion", APP_VERSION)
            params.append("app", "sing_google")
            params.append("appVariant", "1")

            let digest = SmuleDigest.calculateDigest(url, params, null, checkSession && params.has("session"), false, body)
            params.append("digest", digest)

            let headers = {
                "Accept-Encoding": "gzip",
                "Connection": "keep-alive",
                "User-Agent": "com.smule.singandroid/" + APP_VERSION + " (9,SM-S908E,en_US)",
                "Content-Type": "multipart/form-data; boundary=1335a53d-7c46-4dd6-8e1e-c2f96c3987c5"
            }

            this.msgId++

            return this.ax.post(url + `?${params.toString()}`, body.serialize(), {
                headers,
            })
        },

        _createRequest: async (url: string, body: any, isGetRequest = false, checkSession = true) => {
            this.internal._checkUrlAllowed(url)

            let params = new URLSearchParams()
            params.append("app", "sing_google")
            params.append("appVariant", "1")
            params.append("appVersion", APP_VERSION)
            params.append("msgId", this.msgId.toString())
            if (checkSession && this.session && this.session.sessionToken && !this.session.expired) {
                params.append("session", this.session.sessionToken)
            }

            if (typeof body == "object") body = JSON.stringify(body)

            let digest = SmuleDigest.calculateDigest(url, params, body, checkSession && params.has("session"), isGetRequest)
            params.append("digest", digest)

            let headers = {
                "Accept-Encoding": "gzip",
                "Connection": "keep-alive",
                "Content-Type": "application/json", // TODO
                "User-Agent": "com.smule.singandroid/" + APP_VERSION + " (9,SM-S908E,en_US)"
            }

            this.msgId++

            return this.ax.post(url + `?${params.toString()}`, body, {
                headers,
            })
        },

        _getResponseData: <T>(response: AxiosResponse) => {
            let data = response.data as ApiResponse<T>
            return data.data as T
        },

        _getPreuploadLinks: async (arrKey: string, compType: "ARR" | string, ensembleType: EnsembleType, uploadType: "CREATE" | "JOIN", seedKey?: string) => {
            if (!this.account.isLoggedIn()) {
                _error("You must be logged in in order to get preupload links.")
                return
            }
            if (this.session.isGuest) {
                _error("You cannot create a new performance as a guest")
                return
            }

            let req = await this.internal._createRequest(SmuleUrls.PerfPreupload, new PreuploadRequest(arrKey, compType, ensembleType, uploadType, false, seedKey))
            if (!this.internal._handleNon200(req)) return
            return this.internal._getResponseData<PreuploadResult>(req)
        },

        _createPerformance: async (perfReq: PerformanceCreateRequest) => {
            if (!this.account.isLoggedIn()) {
                _error("You must be logged in in order to create a new performance")
                return
            }
            if (this.session.isGuest) {
                _error("You cannot create a new performance as a guest")
                return
            }

            let req = await this.internal._createRequest(SmuleUrls.PerfCreate, perfReq)
            if (!this.internal._handleNon200(req)) return
            return this.internal._getResponseData<PerformanceCreateResult>(req)
        },

        _joinPerformance: async (perfReq: PerformanceCreateRequest) => {
            if (!this.account.isLoggedIn()) {
                _error("You must be logged in in order to join a new performance")
                return
            }
            if (this.session.isGuest) {
                _error("You cannot join a new performance as a guest")
                return
            }

            let req = await this.internal._createRequest(SmuleUrls.PerfJoin, perfReq)
            if (!this.internal._handleNon200(req)) return
            return this.internal._getResponseData<PerformanceCreateResult>(req)
        },

        _uploadPerformance: async (host: string, pop: string, jsonData: string | object, file1: Buffer, file2: Buffer, file3?: Buffer) => {
            if (!this.account.isLoggedIn()) {
                _error("You must be logged in in order to upload a performance")
                return
            }
            if (this.session.isGuest) {
                _error("You cannot upload a performance as a guest")
                return
            }

            let form = new CustomFormData()
            form.set("jsonData", typeof jsonData === "string" ? jsonData : JSON.stringify(jsonData), "application/json; charset=UTF-8")
            form.set("file1", file1, "application/octet-stream", "hi..m4a")
            form.set("file2", file2, "application/octet-stream", "hi.." + (file3 ? ".jpg" : ".bin"))
            if (file3) form.set("file3", file3, "application/octet-stream", "hi..bin")

            let req = await this.internal._createRequestMultiPart(SmuleUrls.getPerformanceUploadUrl(host), pop, form)
            this.internal._handleNon200(req)
        },

        _logreccomplete: async (arrKey: string) => {
            let req = await this.internal._createRequest(SmuleUrls.PerformanceLogRecCompletedArr, { arrKey })
            this.internal._handleNon200(req)
        },
        _storeStreamLog: async (arrKey: string) => {
            let req = await this.internal._createRequest(SmuleUrls.StoreStreamLog, {
                productId: arrKey,
                productType: "ARR",
                type: "own"
            })
            this.internal._handleNon200(req)
        },

        /**
         * throws an error if guest access is not allowed, and session is a guest
         */
        _checkUrlAllowed: (url: string) => {
            if (!this.account.isLoggedIn() && !SmuleUrls.NoSessionRequired.has(url)) {
                // if we are trying to refresh an expired login then just ignore it lol
                if (this.session.expired && !!this.session.refreshToken && url == SmuleUrls.LoginRefresh) return
                throw new Error(`You must be logged in in order to access ${url}`)
            }
            if (!this.session.isGuest) return
            if (SmuleUrls.GuestProhibited.has(url)) {
                throw new Error(`Guest access not allowed for ${url}`)
            }
        }
    }

    /**
     * Account and auth related stuff
     */
    public account = {
        /**
         * Account lookup options
         */
        lookup: {
            /**
             * Look up a user by their email
             * 
             * Usually used for login, but who cares lol
             * @param email The email adress the user utilizes for their account
             * @returns The user's data
             */
            byEmail: async (email: string) => {
                let req = await this.internal._createRequest(SmuleUrls.UserLookup, { email }, false, false)
                if (!this.internal._handleNon200(req)) return
                return this.internal._getResponseData<{ accountIcon: AccountIcon, apps: string[] }>(req)
            },

            /**
             * Look up multiple accounts
             * @param accountIds An array of the accounts' ids
             * @returns The accounts' details
             */
            byIds: async (accountIds: number[]) => {
                let req = await this.internal._createRequest(SmuleUrls.AccountLookup, { accountIds })
                if (!this.internal._handleNon200(req)) return
                return this.internal._getResponseData<UsersLookupResult>(req)
            },

            /**
             * Looks up a single account
             * @param accountId The account's id
             * @returns The account's details
             */
            byId: async (accountId: number) => {
                let data = await this.account.lookup.byIds([accountId])
                return data.accountIcons[0]
            }
        },

        /**
         * Logs in as a guest
         * @returns Whether or not the login was successful
         */
        loginAsGuest: async () => {
            let req = await this.internal._createRequest(SmuleUrls.LoginGuest, new LoginAsGuestRequest(), false, false)
            if (!this.internal._handleNon200(req)) return false

            let res = this.internal._getResponseData<LoginAsGuestResult>(req)
            //* Guests do not receive a refresh token
            this.session.sessionToken = res.loginResult.sessionToken
            this.session.refreshToken = ""
            this.session.isGuest = true
            this.session.expired = false

            _log(`Logged in as player ID ${res.loginResult.playerId} (GUEST)`)
            return true
        },

        /**
         * Log into your account
         * @param email Your email address
         * @param password Your smule account's password
         * @returns Whether the log in was successful
         */
        login: async (email: string, password: string) => {
            let req = await this.internal._createRequest(SmuleUrls.UserLogin, new LoginRequest(email, password), false, false)
            if (!this.internal._handleNon200(req)) return false
            let res = this.internal._getResponseData<LoginResult>(req)
            this.session.sessionToken = res.sessionToken
            this.session.refreshToken = res.refreshToken
            this.session.expired = false
            this.session.isGuest = false
            _log(`Logged in as ${res.handle} (${res.playerId})`)
            return true
        },

        /**
         * Refreshes the session token
         * @returns Whether or not the refresh was successful
         */
        refreshLogin: async () => {
            if (this.session.isGuest) {
                _error("Guests are not allowed to refresh their login.")
                return false
            }
            if (!this.session.refreshToken) {
                _error("Requested to refresh login but no refresh token found. Did you even log in?")
                return false
            }
            if (!this.session.expired) {
                _warn("Refreshing login although session isnt expired?")
                this.session.expired = true // Must be expired in order to refresh
            }

            let req = await this.internal._createRequest(SmuleUrls.LoginRefresh, new LoginRefreshRequest(this.session.refreshToken), false, false)
            if (!this.internal._handleNon200(req)) return false

            let res = this.internal._getResponseData<{ loginResult: LoginResult }>(req)

            this.session.sessionToken = res.loginResult.sessionToken
            this.session.refreshToken = res.loginResult.refreshToken
            this.session.expired = false

            _log(`Refreshed login with player ID ${res.loginResult.playerId}`)
            return true
        },

        /**
         * Checks if you are logged in
         * @returns Whether or not you are logged in
         */
        isLoggedIn: () => {
            return SmuleUtil.checkLoggedIn(this.session)
        },

        /**
         * Fetches your profile
         * @returns Your profile
         */
        fetchSelf: async () => {
            let req = await this.internal._createRequest(SmuleUrls.SingUserProfileMe, { includeActiveState: false })
            if (!this.internal._handleNon200(req)) return
            return this.internal._getResponseData<ProfileResult>(req)
        },

        /**
         * Fetches the details of a specific user
         * @param accountId The id of the user to fetch
         * @returns The user's details
         */
        fetchOne: async (accountId: number) => {
            let req = await this.internal._createRequest(SmuleUrls.SingUserProfile, new ProfileRequest(accountId))
            if (!this.internal._handleNon200(req)) return
            return this.internal._getResponseData<ProfileResult>(req)
        }
    }

    /**
     * Social and chat related stuff
     */
    public social = {
        /**
         * Implements SmuleChat directly in the main Smule class
         */
        chat: {
            /**
             * List with all of the event listeners
             * @see addEventListener
             */
            eventListeners: {},
            /**
             * Creates a new spark chat
             * @param address The JID address of the chat partner
             * @param type Whether the JID address is an individual or a group
             * @returns idk
             */
            create: async (address: string, type: "ACCT" | "GRP" = "ACCT") => {
                let req = await this.internal._createRequest(SmuleUrls.SparkChatUpdate, { add: [{ name: address, type }], remove: [] })
                if (!this.internal._handleNon200(req)) return
                return this.internal._getResponseData<any>(req)
            },
            /**
             * Creates a connection to the XMPP chat server
             */
            connect: async () => {
                if (!this.account.isLoggedIn()) {
                    throw new Error("You must be logged in in order to connect to a chat.")
                }
                if (this.session.isGuest) {
                    throw new Error("You must be logged in as a user in order to connect to a chat.")
                }

                if (this.dmSession && this.dmSession.state == "connected") {
                    _warn("[CHAT] Attempted to reconnect when already connected.")
                    return
                }
                // if (this.dmSession) await this.dmSession.disconnect()
                let exists = this.dmSession != null
                if (!exists) {
                    let user = await this.account.fetchSelf()

                    this.dmSession = new SmuleChat(user.profile.accountIcon.accountId, this.session.sessionToken)
                }

                for (let eventName of ["chatstate", "receipt", "message", "history", "state", "error"]) {
                    if (!this.social.chat.eventListeners[eventName]) this.social.chat.eventListeners[eventName] = []
                    this.dmSession.events.on(eventName, (...args) => {
                        for (let listener of this.social.chat.eventListeners[eventName]) {
                            listener(...args)
                        }
                    })
                }

                if (!exists)
                    await this.dmSession.connect()
            },
            /**
             * Listen to an event
             * @param eventName The event's name
             * @param callback Your callback function
             */
            addEventListener: (eventName: "chatstate" | "receipt" | "message" | "history" | "state" | "error", callback: (...args: any[]) => void) => {
                if (!this.social.chat.eventListeners[eventName]) this.social.chat.eventListeners[eventName] = []
                this.social.chat.eventListeners[eventName].push(callback)
            },
            /**
             * Removes all listeners
             */
            removeAllListeners: () => {
                for (let eventName of ["chatstate", "receipt", "message", "history", "state", "error"]) {
                    this.social.chat.eventListeners[eventName] = []
                }
            },
            /**
             * Disconnect from the XMPP chat server
             * 
             * @remarks If called when still transmitting data,
             *          it might throw an error (socket write after end).
             */
            disconnect: async () => {
                if (!this.dmSession) return
                await this.dmSession.disconnect()
            },
            /**
             * Sends a text message
             * @param to The user to send the message to
             * @param message The message body
             */
            sendTextMessage: async (to: JID | string | AccountIcon, message: string) => {
                if (!this.dmSession) return
                await this.dmSession.sendTextMessage(to, message)
            },
            /**
             * Sends a performance / recording
             * @param to The user to send the message to
             * @param performanceKey The performance key
             */
            sendPerformanceMessage: async (to: JID | string | AccountIcon, performanceKey: string) => {
                if (!this.dmSession) return
                await this.dmSession.sendPerformanceMessage(to, performanceKey)
            },
            /**
             * Sends a read / received receipt
             * @param to The person to inform
             */
            sendReceivedReceipt: async (to: JID | string | AccountIcon) => {
                if (!this.dmSession) return
                await this.dmSession.sendReadReceipt(to)
            },
            /**
             * Fetch all loaded chats
             * @returns All loaded chats
             */
            fetchChats: () => {
                if (!this.dmSession) return
                return this.dmSession.fetchChats()
            },
            /**
             * Fetch a specific chat
             * @param user The chat partner's user id
             * @returns The chat, or an empty new one
             */
            fetchChat: (user: number) => {
                if (!this.dmSession) return
                return this.dmSession.fetchChat(user)
            },
            /**
             * Loads the entire message history
             * @param limit How many messages
             * @param before Messages before this
             * @param after Messages after this
             * @param user The chat partner
             * 
             * @remarks This currently recurses until it loads ALL archived messages.
             *          This means that it will take a long time to load all messages.
             * @remarks Filtering by a specific user may not work yet
             */
            loadMessageHistory: async (limit = 50, before = null, after = null, user?: JID | string) => {
                if (!this.dmSession) return
                await this.dmSession.loadMessageHistory(limit, before, after, user)
            },
            /**
             * Sends a chat state
             * @param user The user to inform
             * @param state The state to send
             */
            sendChatState: async (user: JID | string | AccountIcon, state: SmulePartnerStatus = "active") => {
                if (!this.dmSession) return
                await this.dmSession.sendChatState(user, state)
            },
            /**
             * Transform a JID into a smule user id
             * @param jid The JID itself
             * @returns The smule user id
             */
            getUserIdFromJID: (jid: number | string) => {
                if (!this.dmSession) return
                return this.dmSession.getUserIdFromJID(jid + "")
            },
            /**
             * Transform a smule user id into a JID
             * @param userId The smule user id
             * @returns The JID
             */
            getJIDFromUserId: (userId: number | string) => {
                if (!this.dmSession) return
                return this.dmSession.getJIDFromUserId(userId)
            }
        },

        /**
         * Checks if you're following the specified accounts
         * @param accountIds The ids of the accounts to check
         * @returns The users you're following, and the one's you aren't
         */
        isFollowingUsers: async (accountIds: number[]) => {
            let req = await this.internal._createRequest(SmuleUrls.SocialIsFollowing, new IsFollowingRequest(accountIds))
            if (!this.internal._handleNon200(req)) return
            return this.internal._getResponseData<FollowingResult>(req)
        },

        /**
         * Checks if you're following a specific account.
         * @param accountId The id of the account to check.
         * @returns The user you're following, and an empty array, or vice-versa
         */
        isFollowingUser: async (accountId: number) => {
            return await this.social.isFollowingUsers([accountId])
        },

        /**
         * Follows the specified users.
         * @param accountIds The ids of the accounts to follow.
         */
        followUsers: async (accountIds: number[]) => {
            // There is no return here
            let req = await this.internal._createRequest(SmuleUrls.SocialFolloweeUpdate, new UpdateFollowingRequest(accountIds, []))
            this.internal._handleNon200(req)
        },

        /**
         * Follows a specific user.
         * @param accountId The id of the account to follow.
         */
        followUser: async (accountId: number) => {
            return await this.social.followUsers([accountId])
        },

        /**
         * Unfollows the specified users.
         * @param accountIds The ids of the accounts to unfollow.
         */
        unfollowUsers: async (accountIds: number[]) => {
            // There is no return here
            let req = await this.internal._createRequest(SmuleUrls.SocialFolloweeUpdate, new UpdateFollowingRequest([], accountIds))
            this.internal._handleNon200(req)
        },

        /**
         * Unfollows a specific user.
         * @param accountId The id of the account to unfollow.
         */
        unfollowUser: async (accountId: number) => {
            return await this.social.unfollowUsers([accountId])
        },

        /**
         * Fetches the users that the specified user is following.
         * @param accountId The id of the user to fetch followees from.
         * @returns The users that the user is following.
         * @remarks Smule returns the ENTIRE list of followees, nonpaginated, so make sure you use it wisely
         * @remarks Followee = Following
         */
        fetchFollowings: async (accountId: number) => {
            let req = await this.internal._createRequest(SmuleUrls.SocialFollowee, { accountId })
            if (!this.internal._handleNon200(req)) return
            return this.internal._getResponseData<FolloweeResult>(req)
        },

        /**
         * Fetches the followers of a specific user.
         * @param accountId The id of the user whose followers are to be fetched.
         * @returns The followers of the user.
         * @remarks Smule returns the ENTIRE list of followers, nonpaginated, so make sure you use it wisely
         */
        fetchFollowers: async (accountId: number) => {
            let req = await this.internal._createRequest(SmuleUrls.SocialFollower, { accountId })
            if (!this.internal._handleNon200(req)) return
            return this.internal._getResponseData<FollowersResult>(req)
        },

        /**
         * Fetches comments on a performance.
         * @param performanceKey The performance's key
         * @param offset The starting point for fetching comments. Default is 0.
         * @param limit The maximum number of comments to fetch. Default is 25.
         * @returns The comments on the performance.
         */
        fetchComments: async (performanceKey: string, offset: number = 0, limit: number = 25) => {
            if (offset < 0) {
                _error("Offset must be positive")
                return
            }
            let req = await this.internal._createRequest(SmuleUrls.PerformanceGetComments, {
                limit,
                offset,
                performanceKey,
                roleCheck: true
            })
            if (!this.internal._handleNon200(req)) return
            return this.internal._getResponseData<PerformanceCommentsResult>(req)
        },

        /**
         * Likes a comment.
         * @param performanceKey The key of the performance where the comment is on.
         * @param commentKey The comment's key.
         */
        likeComment: async (performanceKey: string, commentKey: string) => {
            let req = await this.internal._createRequest(SmuleUrls.CommentLike, {
                postKey: commentKey,
                performanceKey
            })
            this.internal._handleNon200(req)
        },

        /**
         * Unlikes a comment.
         * @param performanceKey The key of the performance where the comment is on.
         * @param commentKey The comment's key.
         */
        unlikeComment: async (performanceKey: string, commentKey: string) => {
            let req = await this.internal._createRequest(SmuleUrls.CommentUnlike, {
                postKey: commentKey,
                performanceKey
            })
            this.internal._handleNon200(req)
        },

        /**
         * Fetches the users who liked a specific comment.
         * 
         * @param performanceKey The key of the performance where the comment is on.
         * @param commentKey The comment's key.
         * @returns The likes on the specified comment.
         */
        fetchCommentLikes: async (performanceKey: string, commentKey: string) => {
            let req = await this.internal._createRequest(SmuleUrls.CommentLikes, {
                postKey: commentKey,
                performanceKey
            })
            if (!this.internal._handleNon200(req)) return
            return this.internal._getResponseData<CommentLikesResult>(req)
        },

        /**
         * Creates a comment on a performance.
         * @param performanceKey The key of the performance on which to comment.
         * @param comment The comment to post.
         * @param latitude The latitude to use when posting the comment.
         * @param longitude The longitude to use when posting the comment.
         * @returns The created comment's details.
         */
        createComment: async (performanceKey: string, comment: string, latitude = 37, longitude = -120) => {
            let req = await this.internal._createRequest(SmuleUrls.PerformanceComment, {
                comment,
                latitude,
                longitude,
                performanceKey
            })
            if (!this.internal._handleNon200(req)) return
            return this.internal._getResponseData<PerformanceCreateCommentResult>(req)
        },
        /**
         * Deletes multiple comments on a performance.
         * @param performanceKey The key of the performance where the comments are on.
         * @param postKeys The keys of the comments to delete.
         */
        deleteComments: async (performanceKey: string, postKeys: string[]) => {
            let req = await this.internal._createRequest(SmuleUrls.PerformanceDeleteComment, {
                postKeys,
                performanceKey
            })
            this.internal._handleNon200(req)
        },
        /**
         * Deletes a single comment on a performance.
         * @param performanceKey The key of the performance where the comment is on.
         * @param postKey The key of the comment to delete.
         */
        deleteComment: async (performanceKey: string, postKey: string) => {
            await this.social.deleteComments(performanceKey, [postKey])
        },

        /**
         * Marks a performance as loved.
         *
         * @param performanceKey The performance's key
         */
        likePerformance: async (performanceKey: string) => {
            let req = await this.internal._createRequest(SmuleUrls.PerformanceLove, {
                performanceKey,
                latitude: this.session.latitude,
                longitude: this.session.longitude
            })
            this.internal._handleNon200(req)
        },

        /**
         * Fetches the users that the current user has blocked.
         * @returns The blocked users.
         */
        fetchBlocked: async () => {
            let req = await this.internal._createRequest(SmuleUrls.SocialBlockList, {})
            if (!this.internal._handleNon200(req)) return
            return this.internal._getResponseData<SocialBlockListResult>(req) || { accountIds: [] } // api might return null
        },

        /**
         * Blocks the specified users.
         * @param accountIds The ids of the accounts to block.
         */
        blockUsers: async (accountIds: number[]) => {
            let req = await this.internal._createRequest(SmuleUrls.SocialBlockUpdate, { add: accountIds, remove: [] })
            this.internal._handleNon200(req)
        },

        /**
         * Blocks a specific user.
         * @param accountId The id of the account to block.
         */
        blockUser: async (accountId: number) => {
            return await this.social.blockUsers([accountId])
        },

        /**
         * Unblocks the specified users.
         * @param accountIds The ids of the accounts to unblock.
         */
        unblockUsers: async (accountIds: number[]) => {
            let req = await this.internal._createRequest(SmuleUrls.SocialBlockUpdate, { add: [], remove: accountIds })
            this.internal._handleNon200(req)
        },

        /**
         * Unblocks a specific user.
         * @param accountId The id of the account to unblock.
         */
        unblockUser: async (accountId: number) => {
            return await this.social.unblockUsers([accountId])
        },

        /**
         * Fetches all users that have seen your profile recently.
         * 
         * @param period The period over which to fetch the views. Defaults to "WEEK".
         * @param cursor The cursor over which to fetch views. Defaults to "start".
         * @param limit The number of views to return. Defaults to 10.
         * @returns An object containing the profile views of the current user.
         */
        fetchProfileViews: async (period: "WEEK" | "MONTH" | "QUARTER" = "WEEK", cursor = "start", limit = 10) => {
            let req = await this.internal._createRequest(SmuleUrls.AccountProfileStatsViews, { period, cursor, limit })
            if (!this.internal._handleNon200(req)) return
            return this.internal._getResponseData<ProfileViewsResult>(req)
        },

        /**
         * Fetch performance invites "dedicated" for you.
         * @param cursor The cursor paging thing.
         * @param limit The maximum number of invites to fetch. Default is 20.
         * @returns Some invites.
         */
        fetchPersonalInvites: async (cursor = "start", limit = 20) => {
            let req = await this.internal._createRequest(SmuleUrls.InviteMe, { cursor, limit })
            if (!this.internal._handleNon200(req)) return
            return this.internal._getResponseData<InviteMeResult>(req)
        },

        /**
         * Fetches a list of generic performance invites.
         * @param cursor The cursor paging thing.
         * @param limit The maximum number of invites to fetch. Default is 20.
         * @returns Some invites.
         */
        fetchInvites: async (cursor = "start", limit = 20) => {
            let req = await this.internal._createRequest(SmuleUrls.InviteList, { cursor, limit })
            if (!this.internal._handleNon200(req)) return
            return this.internal._getResponseData<InviteListResult>(req)
        },
    }

    /**
     * Songs / arrangements related stuff
     */
    public songs = {
        /**
         * Fetch recommended songs, which appear on the front page
         * @param cursor Paging
         * @param limit How many per page
         * @returns The "song book"
         */
        fetchSongbook: async (cursor = "start", limit = 10) => {
            let req = await this.internal._createRequest(this.session.isGuest ? SmuleUrls.SongbookGuest : SmuleUrls.Songbook, new SongbookRequest(cursor, limit))
            if (!this.internal._handleNon200(req)) return
            return this.internal._getResponseData<SongbookResult>(req)
        },
        /**
         * Updates your songbook categories.
         * @param categoryIds The ids of the categories that you want to add to your songbook.
         * @returns The updated songbook.
         */
        updateSongbook: async (categoryIds: number[]) => {
            let req = await this.internal._createRequest(SmuleUrls.SongbookUpdate, { categoryIds })
            if (!this.internal._handleNon200(req)) return
            return this.internal._getResponseData<any>(req)
        },

        /**
         * Fetch songs from a certain category
         * @param cursor Paging
         * @param categoryId The category's id
         * @param limit How many per page
         * @returns The songs
         */
        fetchFromCategory: async (cursor = "start", categoryId = 9998, limit = 10, duetAccountId?: number) => {
            let req = await this.internal._createRequest(SmuleUrls.Category, new CategorySongsRequest(cursor, limit, categoryId))
            if (!this.internal._handleNon200(req)) return
            return this.internal._getResponseData<CategorySongsResult>(req)
        },
        /**
         * Fetches a list of song categories.
         * @param sortType The sorting order of the categories. Defaults to "POPULAR".
         * @returns The list of categories sorted by the specified type.
         */
        fetchCategoryList: async (sortType: "POPULAR" | "ALPHA" = "POPULAR") => {
            let req = await this.internal._createRequest(SmuleUrls.CategoryList, { sort: sortType })
            if (!this.internal._handleNon200(req)) return
            return this.internal._getResponseData<CategoryListResult>(req)
        },

        /**
         * Fetches a song using the specified key.
         * 
         * @param key The song / arr key
         * @returns The details of the song
         */
        fetchOne: async (key: string) => {
            let req = await this.internal._createRequest(SmuleUrls.Arr, { arrKey: key })
            if (!this.internal._handleNon200(req)) return
            return this.internal._getResponseData<ArrResult>(req)
        },

        //TODO: raven is also sth ive seen in those official songs too
        //TODO: maybe they have another specialised id?
        fetchOneFromRaven: async (ravenSongId: string) => {
            let req = await this.internal._createRequest(SmuleUrls.ArrFromRSong, { rsongId: ravenSongId })
            if (!this.internal._handleNon200(req)) return
            return this.internal._getResponseData<ArrResult>(req)
        },

        /**
         * Fetches multiple songs at once using their keys.
         * @param keys An array of song / arr keys.
         * @returns The details of the songs.
         */
        fetch: async (keys: string[]) => {
            let req = await this.internal._createRequest(SmuleUrls.ArrByKeys, { arrKeys: keys })
            if (!this.internal._handleNon200(req)) return
            return this.internal._getResponseData<ArrByKeysResult>(req)
        },

        // TODO: test and doc
        fetchOwnedBy: async (ownerId: number, offset = 0, limit = 10) => {
            let req = await this.internal._createRequest(SmuleUrls.ArrOwned, { ownerAccountId: ownerId, offset, limit })
            if (!this.internal._handleNon200(req)) return
            return this.internal._getResponseData<any>(req)
        },

        /**
         * Fetches the lyrics and pitches for a certain arrangement
         * @param key The song / arr key
         * @returns The lyrics, their type, and the pitches
         */
        fetchLyricsAndPitches: async (key: string) => {
            const { arrVersion } = await this.songs.fetchOne(key)
            const filesData = SmuleUtil.getFilesFromArr(arrVersion)
            let req = await axios({
                url: filesData.midi_file || filesData.midi_file_original,
                method: "GET",
                responseType: "arraybuffer",
            })

            const lyrics = SmuleMIDI.fetchLyricsFromMIDI(req.data)

            if (filesData.pitch_file) {
                req = await axios({
                    url: filesData.pitch_file,
                    method: "GET",
                    responseType: "arraybuffer",
                })

                const pitch = SmuleMIDI.fetchPitchesFromMIDI(req.data, lyrics.lyrics)

                return { 
                    lyrics: lyrics.lyrics,
                    pitches: pitch,
                    type: lyrics.type
                }
            }
            return {
                lyrics: lyrics.lyrics,
                pitches: lyrics.pitches,
                type: lyrics.type
            }
        },

        /**
         * Bookmarks a song.
         * @param key The song / arr key.
         * @returns idk
         */
        bookmark: async (key: string) => {
            let req = await this.internal._createRequest(SmuleUrls.ArrBookmark, { arrKey: key })
            if (!this.internal._handleNon200(req)) return
            return this.internal._getResponseData<any>(req) // TODO:
        },
        /**
         * Unbookmarks a song.
         * @param key The song / arr key.
         * @returns idk
         */
        unbookmark: async (key: string) => {
            let req = await this.internal._createRequest(SmuleUrls.ArrBookmarkRemove, { arrKey: key })
            if (!this.internal._handleNon200(req)) return
            return this.internal._getResponseData<any>(req)
        },

        /**
         * Fetches bookmarked songs.
         * @param cursor Paging
         * @param limit The maximum number of songs to fetch
         * @returns idk prolly bookmarks
         */
        fetchBookmarks: async (cursor = "start", limit = 10) => {
            let req = await this.internal._createRequest(SmuleUrls.ArrBookmarkList, { cursor, limit })
            if (!this.internal._handleNon200(req)) return
            return this.internal._getResponseData<any>(req)
        },

        //TODO:
        update: async (key: string, artist?: string, name?: string, tags?: string[]) => {
            let req = await this.internal._createRequest(SmuleUrls.ArrUpdate, { arrKey: key, artist, name, tags })
            if (!this.internal._handleNon200(req)) return
            return this.internal._getResponseData<any>(req)
        },

        //TODO:
        vote: async (key: string, arrVersion: number, reason: string, vote: "UP" | "DOWN") => {
            let req = await this.internal._createRequest(SmuleUrls.ArrVote, { arrKey: key, ver: arrVersion, reason, vote })
            if (!this.internal._handleNon200(req)) return
            return this.internal._getResponseData<any>(req)
        },

        //TODO:
        delete: async (key: string, deletePerformances = true) => {
            let req = await this.internal._createRequest(SmuleUrls.ArrDelete, { arrKey: key, deletePerfs: deletePerformances })
            if (!this.internal._handleNon200(req)) return
            return this.internal._getResponseData<any>(req)
        },
    }

    /**
     * Performance / recording related stuff
     */
    public performances = {
        /**
         * Account lookup options
         */
        lookUp: {
            /**
             * Look up multiple performances at once
             * @param performanceKeys An array of performance keys
             * @returns The performances' details
             */
            byKeys: async (performanceKeys: string[]) => {
                let req = await this.internal._createRequest(SmuleUrls.PerformanceByKeys, { performanceKeys })
                if (!this.internal._handleNon200(req)) return
                return this.internal._getResponseData<PerformanceByKeysResult>(req)
            },

            /**
             * Looks up a single performance
             * @param performanceKey The performance key
             * @returns The performance's details
             */
            byKey: async (performanceKey: string) => {
                let data = await this.performances.lookUp.byKeys([performanceKey])
                return data!.performanceIcons[0]
            },

            /**
             * Look up performances by a specific user
             * @param cursor Paging
             * @param userId The user's ID
             * @param limit How many per page
             * @returns The performances
             */
            byUser: async (accountId: number, limit = 20, offset = 0) => {
                let req = await this.internal._createRequest(SmuleUrls.PerformanceParts, new PerformancesByUserRequest(accountId, limit, offset))
                if (!this.internal._handleNon200(req)) return
                return this.internal._getResponseData<PerformancesByUserResult>(req)
            },

            /**
             * Fetches performances based on the specified AV template.
             *
             * @param templateId The id of the AV template.
             * @param cursor The paging cursor. Default is "start".
             * @param limit The maximum number of performances to fetch. Default is 10.
             * @param performanceKey For some reason, a performance key? (optional)
             * @returns The performances associated with the given AV template.
             */
            byAvTemplate: async (templateId: number, cursor = "start", limit = 10, performanceKey?: string) => {
                let req = await this.internal._createRequest(SmuleUrls.DiscoveryPerfByAvTemplateList, { avTemplateId: templateId, cursor, limit, performanceKey })
                if (!this.internal._handleNon200(req)) return
                return this.internal._getResponseData<PerformancesByAvTemplateResult>(req)
            }
        },

        /**
         * Retrieves a list of performances based on the specified criteria.
         * 
         * @param sort The order in which to sort the performances (default is SUGGESTED).
         * @param fillStatus The fill status of the performances (default is ACTIVESEED).
         * @param limit The maximum number of performances to fetch (default is 20).
         * @param offset The starting point for fetching performances (default is 0).
         * @returns The performances.
         */
        list: async (sort: PerformancesSortOrder = "SUGGESTED", fillStatus: PerformancesFillStatus = "ACTIVESEED", limit = 20, offset = 0) => {
            const req = await this.internal._createRequest(SmuleUrls.PerformanceList, new PerformancesListRequest(sort, fillStatus, limit, offset))
            if (!this.internal._handleNon200(req)) return
            return this.internal._getResponseData<PerformanceList>(req)
        },

        /**
         * Retrieves a list of performances / recordings based on the specified criteria.
         * 
         * @param key The arr key associated with the song.
         * @param sort The order in which to sort the performances (default is RECENT).
         * @param fillStatus The fill status of the performances (default is ACTIVESEED).
         * @param limit The maximum number of performances to fetch (default is 25).
         * @param offset The starting point for fetching performances (default is 0).
         * @param video Whether to retrieve only video performances.
         * @returns The performances.
         */
        fetchList: async (key: string, sort: PerformancesSortOrder = "RECENT", fillStatus: PerformancesFillStatus = "ACTIVESEED", limit = 25, offset = 0, video?: boolean) => {
            const req = await this.internal._createRequest(SmuleUrls.PerformanceList, new PerformanceReq(key, sort, fillStatus, limit, offset, video))
            if (!this.internal._handleNon200(req)) return
            return this.internal._getResponseData<PerformanceList>(req)
        },

        /**
         * Retrieves a list of performances based on the specified criteria.
         * 
         * @param requests An array of PerformanceReq objects. Each object contains the criteria for fetching performances.
         * @returns The performance lists.
         */
        fetchLists: async (requests: PerformanceReq[]) => {
            let req = await this.internal._createRequest(SmuleUrls.PerformanceLists, { perfRequests: requests })
            if (!this.internal._handleNon200(req)) return
            return this.internal._getResponseData<{ perfLists: PerformanceList[] }>(req)
        },

        /**
         * Fetches a performance by its key
         * @param performanceKey The performance's key.
         * @returns The performance's details
         */
        fetchOne: async (performanceKey: string) => {
            let req = await this.internal._createRequest(SmuleUrls.PerformanceUrl, { performanceKey })
            if (!this.internal._handleNon200(req)) return
            return this.internal._getResponseData<PerformanceResult>(req)
        },

        /**
         * Fetches the performances of a specific user, sorted by the specified method with the specified fill status.
         * @param accountId The id of the user to fetch performances from
         * @param fillStatus The fill status of the performances to fetch. Default is FILLED.
         * @param sortMethod The method to sort the performances by. Default is NEWEST_FIRST.
         * @param limit The maximum number of performances to fetch. Default is 20.
         * @param offset The starting point for fetching performances. Default is 0.
         * @returns The performances of the user
         */
        fetchFromAccount: async (accountId: number, fillStatus: PerformancesFillStatus = "FILLED", sortMethod: PerformanceSortMethod = "NEWEST_FIRST", limit: number = 20, offset: number = 0) => {
            let req = await this.internal._createRequest(SmuleUrls.PerformanceParts, new PerformancePartsRequest(accountId, fillStatus, sortMethod, limit, offset))
            if (!this.internal._handleNon200(req)) return
            return this.internal._getResponseData<PerformancePartsResult>(req)
        },

        /**
         * Fetches the children performances of a specific performance.
         * @param performanceKey The performance's key.
         * @param limit The maximum number of children performances to fetch. Default is 25.
         * @param offset The starting point for fetching children performances. Default is 0.
         * @returns The children performances of the given performance.
         */
        fetchChildren: async (performanceKey: string, limit = 25, offset = 0) => {
            let req = await this.internal._createRequest(SmuleUrls.PerformanceChildren, { performanceKey, limit, offset })
            if (!this.internal._handleNon200(req)) {
                return {
                    performanceIcons: [],
                    next: -1
                } as PerformanceList
            }
            return this.internal._getResponseData<PerformanceList>(req)
        },
        /**
         * Fetches the details of multiple performances at once.
         * @param performanceKeys The keys of the performances to fetch.
         * @returns The details of the performances.
         */
        fetchDetails: async (performanceKeys: string[]) => {
            let req = await this.internal._createRequest(SmuleUrls.PerformanceListDetails, { keys: performanceKeys, returnAvTemplateDetails: true, returnBookmarked: true, returnLoved: true, returnRestricted: true, returnTopComment: true })
            if (!this.internal._handleNon200(req)) return
            return this.internal._getResponseData<PerformanceDetailsResult>(req)
        },
        /**
         * Fetches the details of a single performance.
         * @param performanceKey The key of the performance to fetch.
         * @returns The details of the specified performance.
         */
        fetchDetailsForOne: async (performanceKey: string): Promise<PerformanceDetail> => {
            return (await this.performances.fetchDetails([performanceKey])).performanceDetails[0]
        },

        /**
         * Uploads a performance to Smule, using the default metadata that SmuleAudio
         * generates.
         * 
         * @param createRequest The `PerformanceCreateRequest` object that contains all the necessary information to create a performance.
         * @param uploadType The type of upload. Can be either `"CREATE"` or `"JOIN"`.
         * @param audioFile The audio file to be uploaded.
         * @param coverFile The cover image file to be uploaded. If not provided, no cover image will be uploaded.
         * @param updateThisPerformance The performance to be updated. If not provided, a new performance will be created.
         * @returns The uploaded performance.
         */
        uploadAuto: async (createRequest: PerformanceCreateRequest, uploadType: "CREATE" | "JOIN", audioFile: Buffer | string, coverFile?: Buffer | string, updateThisPerformance?: PerformanceIcon | any) => {
            let meta = Buffer.from(JSON.stringify(SmuleAudio.createMetadataJSON()))
            return await this.performances.upload(createRequest, uploadType, audioFile, meta, coverFile, updateThisPerformance);
        },


        /**
         * Uploads a performance to Smule.
         * 
         * @param createRequest The `PerformanceCreateRequest` object that contains all the necessary information to create a performance.
         * @param uploadType The type of upload. Can be either `"CREATE"` or `"JOIN"`.
         * @param audioFile The audio file to be uploaded.
         * @param metaFile The metadata file to be uploaded.
         * @param coverFile The cover image file to be uploaded. If not provided, no cover image will be uploaded.
         * @param updateThisPerformance The performance to be updated. If not provided, a new performance will be created.
         * @returns The uploaded performance.
         */
        upload: async (createRequest: PerformanceCreateRequest, uploadType: "CREATE" | "JOIN", audioFile: Buffer | string, metaFile: Buffer | string, coverFile?: Buffer | string, updateThisPerformance?: PerformanceIcon | any) => {
            if (!this.account.isLoggedIn()) {
                _error("You must be logged in in order to upload a performance")
                return
            }
            if (this.session.isGuest) {
                _error("You cannot upload a performance as a guest")
                return
            }
            if (typeof audioFile == "string") {
                audioFile = readFileSync(audioFile)
            }
            if (typeof metaFile == "string") {
                metaFile = readFileSync(metaFile)
            }
            if (typeof coverFile == "string") {
                coverFile = readFileSync(coverFile)
            }

            await this.internal._logreccomplete(createRequest.arrKey)

            let links = await this.internal._getPreuploadLinks(createRequest.arrKey, createRequest.compType, createRequest.ensembleType, uploadType, createRequest.performanceKey)
            if (!links) return _error("Failed to get preupload links")

            await this.internal._storeStreamLog(createRequest.arrKey)

            // TODO: remake the whole upload procedure because there may be a chance that
            // TODO: there are different hostnames for different resource types and/or
            // TODO: for `pop`s

            let hostName = ""
            let pop = ""
            for (let resource of links.resources) {
                if (!hostName || !pop) {
                    hostName = resource.hostname
                    pop = resource.pop
                }
                if (resource.resourceType == "AUDIO")
                    createRequest.audioResourceId = resource.resourceId
                else if (resource.resourceType == "META")
                    createRequest.metadataResourceId = resource.resourceId
                else if (resource.resourceType == "IMAGE")
                    createRequest.coverResourceId = resource.resourceId
            }

            let performance;
            if (!updateThisPerformance) {
                if (uploadType == "CREATE") {
                    performance = await this.internal._createPerformance(createRequest)
                } else {
                    performance = await this.internal._joinPerformance(createRequest)
                }
                if (!performance) return _error("Failed to create performance")
                console.log(performance)
            } else {
                performance = updateThisPerformance
            }

            if (coverFile) {
                await this.internal._uploadPerformance(hostName, pop, {
                    file1ResourceInfo: {
                        hostname: hostName,
                        pop,
                        resourceId: createRequest.audioResourceId,
                        resourceType: "AUDIO"
                    },
                    file2ResourceInfo: {
                        hostname: hostName,
                        pop,
                        resourceId: createRequest.coverResourceId,
                        resourceType: "IMAGE"
                    },
                    file3ResourceInfo: {
                        hostname: hostName,
                        pop,
                        resourceId: createRequest.metadataResourceId,
                        resourceType: "META"
                    },
                    performanceKey: performance.performance.performanceKey,
                    trackKey: performance.trackKey,
                    uploadType
                }, audioFile, coverFile, metaFile)
            } else {
                await this.internal._uploadPerformance(hostName, pop, {
                    file1ResourceInfo: {
                        hostname: hostName,
                        pop,
                        resourceId: createRequest.audioResourceId,
                        resourceType: "AUDIO"
                    },
                    file2ResourceInfo: {
                        hostname: hostName,
                        pop,
                        resourceId: createRequest.metadataResourceId,
                        resourceType: "META"
                    },
                    performanceKey: performance.performance.performanceKey,
                    trackKey: performance.trackKey,
                    uploadType
                }, audioFile, metaFile)
            }

            return performance
        },

        /**
         * Deletes a performance.
         * 
         * @param performanceKey The key of the performance to be deleted.
         */
        deleteOne: async (performanceKey: string) => {
            let req = await this.internal._createRequest(SmuleUrls.PerformanceDelete, { performanceKey })
            this.internal._handleNon200(req)
        }
    }

    /**
     * Search related stuff
     */
    public search = {
        /**
         * Fetches the current trending searches on Smule.
         * @returns The trending searches currently available
         */
        fetchTrending: async () => {
            let req = await this.internal._createRequest(SmuleUrls.RecTsrch, {})
            if (!this.internal._handleNon200(req)) return
            return this.internal._getResponseData<TrendingSearchResult>(req)
        },

        /**
         * Searches on Smule
         * @param query The query to search for
         * @returns The search result
         */
        perform: async (query: string) => {
            let req = await this.internal._createRequest(SmuleUrls.SearchGlobal, { includeRecording: 0, term: query })
            if (!this.internal._handleNon200(req)) return
            return this.internal._getResponseData<SearchResult>(req)
        },

        /**
         * Performs a specific search on Smule based on the provided query and parameters.
         * @param query The search term to be used in the query.
         * @param type The type of search result to be returned (e.g., song, user).
         * @param sort The sorting order of the search results (default is POPULAR).
         * @param cursor The paging cursor for the search results (default is "start").
         * @param limit The maximum number of search results to return (default is 25).
         * @returns The search results matching the specified criteria.
         */
        performSpecific: async (query: string, type: SearchResultType, sort: SearchResultSort = "POPULAR", cursor = "start", limit = 25) => {
            let req = await this.internal._createRequest(SmuleUrls.Search, new SearchRequest(cursor, limit, type, sort, query))
            if (!this.internal._handleNon200(req)) return
            return this.internal._getResponseData<SearchResult>(req)
        },

        /**
         * Gets autocomplete suggestions for a given query
         * @param query The query to get autocomplete suggestions for
         * @param limit The maximum number of suggestions to return (default is 5)
         * @returns The autocomplete suggestions
         */
        fetchAutocomplete: async (query: string, limit = 5) => {
            let req = await this.internal._createRequest(SmuleUrls.SearchAutocomplete, new AutocompleteRequest(query, limit))
            if (!this.internal._handleNon200(req)) return
            return this.internal._getResponseData<AutocompleteResult>(req)
        }
    }

    /**
     * AvTemplates related stuff
     */
    public avTemplates = {
        /**
         * Fetches a list of AV templates.
         * 
         * @param limit The maximum number of AV templates to fetch. Default is 25.
         * @returns The fetched AV templates.
         */
        fetch: async (limit = 25) => {
            let req = await this.internal._createRequest(SmuleUrls.AvtemplateCategoryList, new AvTemplateCategoryListRequest("AUDIO", "start", limit, "STANDARD"))
            if (!this.internal._handleNon200(req)) return
            return this.internal._getResponseData<AvTemplateCategoryListResult>(req)
        }
    }

    /**
     * Telemetry stuff
     */
    public telemetry = {
        /**
         * Marks a song as played.
         * 
         * @param arrKey The key associated with the song to be marked as played.
         */
        markSongAsPlayed: async (arrKey: string) => {
            // _log("Marking song as played...")
            let req = await this.internal._createRequest(SmuleUrls.ArrPlay, { arrKey })
            this.internal._handleNon200(req)
        },

        /**
         * Marks a performance as played.
         * 
         * @param performanceKey The key associated with the performance to be marked as played.
         */
        markPerformanceAsPlayed: async (performanceKey: string) => {
            // _log("Marking performance as played...")
            let req = await this.internal._createRequest(SmuleUrls.PerformancePlay, { performanceKey })
            this.internal._handleNon200(req)
        },

        /**
         * Marks a performance as "started to be listened to" by the user.
         * This is used to track user activity and to provide recommendations.
         * @param performanceKey The key associated with the performance to be marked as listened to.
         */
        markPerformanceListenStart: async (performanceKey: string) => {
            // _log("Marking performance as listened to...")
            let req = await this.internal._createRequest(SmuleUrls.PerformanceListenStart, { performanceKey })
            this.internal._handleNon200(req)
        }
    }

    /**
     * Discovery / explore page stuff
     */
    public explore = {
        /**
         * Explores the playlists on Smule, which are curated lists of performances.
         * @returns The playlists that match the specified criteria.
         */
        fetchPlaylists: async () => {
            let req = await this.internal._createRequest(SmuleUrls.PlaylistExplore, {})
            if (!this.internal._handleNon200(req)) return
            return this.internal._getResponseData<PlaylistExploreResult>(req)
        },

        /**
         * Fetches a playlist by its ID.
         * @param playlistId The ID of the playlist to be fetched.
         * @param offset The starting point for fetching the playlist. Default is 0.
         * @param limit The maximum number of items to fetch in the playlist. Default is 10.
         * @returns The playlist with the specified details.
         */
        fetchPlaylist: async (playlistId: number, offset = 0, limit = 10) => {
            let req = await this.internal._createRequest(SmuleUrls.PlaylistGet, { playlistId, offset, limit })
            if (!this.internal._handleNon200(req)) return
            return this.internal._getResponseData<PlaylistGetResult>(req)
        },

        /**
         * Explores the users on Smule, which can be used to discover new users.
         * @param cursor The paging cursor for the users. Default is "start", which will fetch the first 20 users.
         * @param limit The maximum number of users to fetch. Default is 20.
         * @returns The users that match the specified criteria.
         */
        fetchAccounts: async (cursor = "start", limit = 20) => {
            let req = await this.internal._createRequest(SmuleUrls.AccountExplore, { cursor, limit })
            if (!this.internal._handleNon200(req)) return
            return this.internal._getResponseData<AccountExploreResult>(req)
        },

        /**
         * Explores the groups on Smule, which are often used for collaboration.
         * @param cursor The paging cursor for the groups. Default is "start".
         * @param limit The maximum number of groups to fetch. Default is 10.
         * @param sortBy The sorting order for the groups. Default is "RECOMMENDED", which will sort by Smule's algorithmic recommendation.
         * @returns The groups matching the specified criteria.
         */
        fetchGroups: async (cursor = "start", limit = 10, sortBy = "RECOMMENDED") => {
            let req = await this.internal._createRequest(SmuleUrls.SfamList, { cursor, limit, sortBy })
            if (!this.internal._handleNon200(req)) return
            return this.internal._getResponseData<SFAMExploreResult>(req)
        },

        /**
         * Explores the livestreams available to the user.
         * @param cursor The starting point for fetching livestreams. Default is "start".
         * @param limit The maximum number of livestreams to fetch. Default is 20.
         * @param sort The sorting order of the livestreams. Default is "POPULAR".
         * @returns The livestreams that match the specified criteria.
         * @remarks You must be logged in and not a guest in order to explore livestreams.
         */
        fetchLivestreams: async (cursor = "start", limit = 20, sort = "POPULAR") => {
            let self = await this.account.fetchSelf()
            let req = await this.internal._createRequest(SmuleUrls.CfireList, { accountId: self.profile.accountIcon.accountId, cursor, limit, sort })
            if (!this.internal._handleNon200(req)) return
            return this.internal._getResponseData<CampfireExploreResult>(req)
        },

        /**
         * Fetches the feed of the user, which contains posts and songs from the users that the user follows.
         * @param cursor The starting point for fetching feed items. Default is "start", which will fetch the first 20 items.
         * @param limit The maximum number of items to fetch. Default is 20.
         * @returns The feed items of the user.
         * @remarks You must be logged in in order to fetch your feed.
         */
        fetchFeed: async (cursor = "start", limit = 20) => {
            let req = await this.internal._createRequest(SmuleUrls.SocialFeedList, { cursor, limit })
            if (!this.internal._handleNon200(req)) return
            return this.internal._getResponseData<SocialFeedListResult>(req)
        },
    }

    // utterly useless but it's here if needed
    public settings = {
        fetch: async () => {
            let req = await this.internal._createRequest(SmuleUrls.Settings, new SettingsRequest())
            if (!this.internal._handleNon200(req)) return
            return this.internal._getResponseData<SettingsResult>(req)
        }
    }

    public live = {
        /**
         * Implements SmuleChat directly in the main Smule class for livestreams
         */
        chat: {
            /**
             * List with all of the event listeners
             * @see addEventListener
             */
            eventListeners: {},
            /**
             * Creates a connection to the XMPP chat server
             */
            connect: async (host: string, cfireJID: string) => {
                if (!this.account.isLoggedIn()) {
                    _error("You must be logged in in order to connect to a chat.")
                    return
                }
                if (this.session.isGuest) {
                    _error("You must be logged in as a user in order to connect to a chat.")
                    return
                }

                if (this.liveChatSession && this.liveChatSession.state == "connected") {
                    _warn("[LIVECHAT] Attempted to reconnect when already connected.")
                    return
                }
                try {
                    if (this.dmSession) await this.dmSession.disconnect()
                } catch {}

                const user = await this.account.fetchSelf()
                this.liveChatSession = new SmuleLiveChat(user.profile.accountIcon.accountId, this.session.sessionToken, host, cfireJID)
                

                for (let eventName of ["chatstate", "receipt", "message", "history", "state", "error", "presence"]) {
                    if (!this.live.chat.eventListeners[eventName]) this.live.chat.eventListeners[eventName] = []
                    this.liveChatSession.events.on(eventName, (...args) => {
                        for (let listener of this.live.chat.eventListeners[eventName]) {
                            listener(...args)
                        }
                    })
                }
                await this.liveChatSession.connect()
            },
            /**
             * Listen to an event
             * @param eventName The event's name
             * @param callback Your callback function
             */
            addEventListener: (eventName: "performance-start" | "create-mic-request" | "cancel-mic-request" | "message" | "history" | "state" | "error" | "presence" | "gift-sent" | "new-host" | "host-left", callback: (...args: any[]) => void) => {
                if (!this.live.chat.eventListeners[eventName]) this.live.chat.eventListeners[eventName] = []
                this.live.chat.eventListeners[eventName].push(callback)
            },
            /**
             * Removes all listeners
             */
            removeAllListeners: () => {
                for (let eventName of ["performance-start", "create-mic-request", "cancel-mic-request", "message", "history", "state", "error", "presence", "gift-sent", "new-host", "host-left"]) {
                    this.live.chat.eventListeners[eventName] = []
                }
            },
            /**
             * Disconnect from the XMPP chat server
             * 
             * @remarks If called when still transmitting data,
             *          it might throw an error (socket write after end).
             */
            disconnect: async () => {
                if (!this.liveChatSession) return
                await this.liveChatSession.disconnect()
            },
            /**
             * Sends a text message
             * @param to The user to send the message to
             * @param message The message body
             */
            sendTextMessage: async (to: JID | string | AccountIcon, message: string) => {
                if (!this.liveChatSession) return
                await this.liveChatSession.sendTextMessage(to, message)
            },
            /**
             * Fetch all loaded chats
             * @returns All loaded chats
             */
            fetchChat: () => {
                if (!this.liveChatSession) return
                return this.liveChatSession.fetchChat()
            },

            fetchUsers: () => {
                if (!this.liveChatSession) return
                return this.liveChatSession.fetchUsers()
            },

            /**
             * Loads the entire message history
             * @param limit How many messages
             * @param before Messages before this
             * @param after Messages after this
             * @param user The chat partner
             * 
             * @remarks This currently recurses until it loads ALL archived messages.
             *          This means that it will take a long time to load all messages.
             * @remarks Filtering by a specific user may not work yet
             */
            loadMessageHistory: async (limit = 50, before = null, after = null, user?: JID | string) => {
                if (!this.liveChatSession) return
                await this.liveChatSession.loadMessageHistory(limit, before, after, user)
            },
        },
        fetch: async (campfireId: number) => {
            let req = await this.internal._createRequest(SmuleUrls.CfireSync, {campfireId})
            if (!this.internal._handleNon200(req)) return
            return this.internal._getResponseData<CampfireSyncResult>(req)
        }
    }

    // shit i try to test
    public TEST = {
        runRawRequest: async (url: string, data: any) => {
            return await this.internal._createRequest(url, data)
        }
    }
}